# FROM registry.access.redhat.com/ubi8/python-312:latest

# WORKDIR /app

# COPY server.py .
# COPY requirements.txt .

# RUN pip install --no-cache-dir -r requirements.txt

# EXPOSE 8080

# CMD ["python", "server.py"]

# Stage 1: Use an official Python runtime as a parent image
# Using a 'slim' version keeps the final image size smaller.
FROM python:3.12-slim

# Stage 2: Set the working directory inside the container
WORKDIR /app

# Stage 3: Install dependencies
# First, copy only the requirements file to leverage Docker's build cache.
# This step is only re-run if requirements.txt changes.
COPY ./agents/requirements.txt .
RUN pip install --no-cache-dir --upgrade pip -r requirements.txt

# Stage 4: Copy your application code into the container
# This copies everything from your 'engine' folder into the container's /app directory.
# COPY . .
# COPY ./.venv ./.venv
COPY ./api ./api
COPY ./ml ./ml
COPY ./resources ./resources
# COPY ./__init__.py ./__init__.py
COPY ./.env ./.env
# COPY ./.python-version ./.python-version
# COPY ./pyproject.toml ./pyproject.toml
# COPY ./uv.lock ./uv.lock
COPY ./agents ./agents
COPY ./rag/rag_with_ollama.py ./rag/rag_with_ollama.py
COPY ./rag/chroma_capstone_db_new_small ./rag/chroma_capstone_db_new_small


# Stage 5: Expose the port the app runs on
# This informs Docker that the container listens on port 8080.
EXPOSE 8080

# Stage 6: Define the command to run your application
# This runs uvicorn, making the server accessible from outside the container.
# We remove '--reload' as it's not needed for production.
# CMD ["uvicorn", "api.agent_api:app", "--host", "0.0.0.0", "--port", "8080"]

CMD ["python", "./agents/start_server.py", "--host", "0.0.0.0", "--port", "8080"]
{
  "project": "Research Data/langflow",
  "repo": "langflow-ai/langflow",
  "prior_commit": "30c678b2937656e9f1b53c6d80123f84779d8ad1",
  "researched_commit": "7aeb687533e53027aa477722d06d337b1a210ac6",
  "compare_url": "https://github.com/langflow-ai/langflow/compare/30c678b2937656e9f1b53c6d80123f84779d8ad1...7aeb687533e53027aa477722d06d337b1a210ac6",
  "ahead_by": 1,
  "behind_by": 0,
  "changed_files": [
    {
      "path": "src/backend/base/langflow/base/agents/agent.py",
      "status": "modified",
      "additions": 18,
      "deletions": 3,
      "patch": "@@ -4,6 +4,7 @@\n \n from langchain.agents import AgentExecutor, BaseMultiActionAgent, BaseSingleActionAgent\n from langchain.agents.agent import RunnableAgent\n+from langchain_core.messages import HumanMessage\n from langchain_core.runnables import Runnable\n \n from langflow.base.agents.callback import AgentAsyncHandler\n@@ -12,7 +13,7 @@\n from langflow.custom.custom_component.component import Component, _get_component_toolkit\n from langflow.field_typing import Tool\n from langflow.inputs.inputs import InputTypes, MultilineInput\n-from langflow.io import BoolInput, HandleInput, IntInput, MessageTextInput\n+from langflow.io import BoolInput, HandleInput, IntInput, MessageInput\n from langflow.logging import logger\n from langflow.memory import delete_message\n from langflow.schema.content_block import ContentBlock\n@@ -34,7 +35,7 @@\n class LCAgentComponent(Component):\n     trace_type = \"agent\"\n     _base_inputs: list[InputTypes] = [\n-        MessageTextInput(\n+        MessageInput(\n             name=\"input_value\",\n             display_name=\"Input\",\n             info=\"The input provided by the user for the agent to process.\",\n@@ -135,14 +136,28 @@ async def run_agent(\n                 verbose=verbose,\n                 max_iterations=max_iterations,\n             )\n-        input_dict: dict[str, str | list[BaseMessage]] = {\"input\": self.input_value}\n+        input_dict: dict[str, str | list[BaseMessage]] = {\n+            \"input\": self.input_value.to_lc_message() if isinstance(self.input_value, Message) else self.input_value\n+        }\n         if hasattr(self, \"system_prompt\"):\n             input_dict[\"system_prompt\"] = self.system_prompt\n         if hasattr(self, \"chat_history\") and self.chat_history:\n             if isinstance(self.chat_history, Data):\n                 input_dict[\"chat_history\"] = data_to_messages(self.chat_history)\n             if all(isinstance(m, Message) for m in self.chat_history):\n                 input_dict[\"chat_history\"] = data_to_messages([m.to_data() for m in self.chat_history])\n+        if hasattr(input_dict[\"input\"], \"content\") and isinstance(input_dict[\"input\"].content, list):\n+            # ! Because the input has to be a string, we must pass the images in the chat_history\n+\n+            image_dicts = [item for item in input_dict[\"input\"].content if item.get(\"type\") == \"image\"]\n+            input_dict[\"input\"].content = [item for item in input_dict[\"input\"].content if item.get(\"type\") != \"image\"]\n+\n+            if \"chat_history\" not in input_dict:\n+                input_dict[\"chat_history\"] = []\n+            if isinstance(input_dict[\"chat_history\"], list):\n+                input_dict[\"chat_history\"].extend(HumanMessage(content=[image_dict]) for image_dict in image_dicts)\n+            else:\n+                input_dict[\"chat_history\"] = [HumanMessage(content=[image_dict]) for image_dict in image_dicts]\n \n         if hasattr(self, \"graph\"):\n             session_id = self.graph.session_id",
      "patch_lines": [
        "@@ -4,6 +4,7 @@\n",
        " \n",
        " from langchain.agents import AgentExecutor, BaseMultiActionAgent, BaseSingleActionAgent\n",
        " from langchain.agents.agent import RunnableAgent\n",
        "+from langchain_core.messages import HumanMessage\n",
        " from langchain_core.runnables import Runnable\n",
        " \n",
        " from langflow.base.agents.callback import AgentAsyncHandler\n",
        "@@ -12,7 +13,7 @@\n",
        " from langflow.custom.custom_component.component import Component, _get_component_toolkit\n",
        " from langflow.field_typing import Tool\n",
        " from langflow.inputs.inputs import InputTypes, MultilineInput\n",
        "-from langflow.io import BoolInput, HandleInput, IntInput, MessageTextInput\n",
        "+from langflow.io import BoolInput, HandleInput, IntInput, MessageInput\n",
        " from langflow.logging import logger\n",
        " from langflow.memory import delete_message\n",
        " from langflow.schema.content_block import ContentBlock\n",
        "@@ -34,7 +35,7 @@\n",
        " class LCAgentComponent(Component):\n",
        "     trace_type = \"agent\"\n",
        "     _base_inputs: list[InputTypes] = [\n",
        "-        MessageTextInput(\n",
        "+        MessageInput(\n",
        "             name=\"input_value\",\n",
        "             display_name=\"Input\",\n",
        "             info=\"The input provided by the user for the agent to process.\",\n",
        "@@ -135,14 +136,28 @@ async def run_agent(\n",
        "                 verbose=verbose,\n",
        "                 max_iterations=max_iterations,\n",
        "             )\n",
        "-        input_dict: dict[str, str | list[BaseMessage]] = {\"input\": self.input_value}\n",
        "+        input_dict: dict[str, str | list[BaseMessage]] = {\n",
        "+            \"input\": self.input_value.to_lc_message() if isinstance(self.input_value, Message) else self.input_value\n",
        "+        }\n",
        "         if hasattr(self, \"system_prompt\"):\n",
        "             input_dict[\"system_prompt\"] = self.system_prompt\n",
        "         if hasattr(self, \"chat_history\") and self.chat_history:\n",
        "             if isinstance(self.chat_history, Data):\n",
        "                 input_dict[\"chat_history\"] = data_to_messages(self.chat_history)\n",
        "             if all(isinstance(m, Message) for m in self.chat_history):\n",
        "                 input_dict[\"chat_history\"] = data_to_messages([m.to_data() for m in self.chat_history])\n",
        "+        if hasattr(input_dict[\"input\"], \"content\") and isinstance(input_dict[\"input\"].content, list):\n",
        "+            # ! Because the input has to be a string, we must pass the images in the chat_history\n",
        "+\n",
        "+            image_dicts = [item for item in input_dict[\"input\"].content if item.get(\"type\") == \"image\"]\n",
        "+            input_dict[\"input\"].content = [item for item in input_dict[\"input\"].content if item.get(\"type\") != \"image\"]\n",
        "+\n",
        "+            if \"chat_history\" not in input_dict:\n",
        "+                input_dict[\"chat_history\"] = []\n",
        "+            if isinstance(input_dict[\"chat_history\"], list):\n",
        "+                input_dict[\"chat_history\"].extend(HumanMessage(content=[image_dict]) for image_dict in image_dicts)\n",
        "+            else:\n",
        "+                input_dict[\"chat_history\"] = [HumanMessage(content=[image_dict]) for image_dict in image_dicts]\n",
        " \n",
        "         if hasattr(self, \"graph\"):\n",
        "             session_id = self.graph.session_id\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/base/agents/events.py",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "patch": "@@ -63,8 +63,14 @@ async def handle_on_chain_start(\n         input_data = event[\"data\"].get(\"input\")\n         if isinstance(input_data, dict) and \"input\" in input_data:\n             # Cast the input_data to InputDict\n+            input_message = input_data.get(\"input\", \"\")\n+            if isinstance(input_message, BaseMessage):\n+                input_message = input_message.text()\n+            elif not isinstance(input_message, str):\n+                input_message = str(input_message)\n+\n             input_dict: InputDict = {\n-                \"input\": str(input_data.get(\"input\", \"\")),\n+                \"input\": input_message,\n                 \"chat_history\": input_data.get(\"chat_history\", []),\n             }\n             text_content = TextContent(",
      "patch_lines": [
        "@@ -63,8 +63,14 @@ async def handle_on_chain_start(\n",
        "         input_data = event[\"data\"].get(\"input\")\n",
        "         if isinstance(input_data, dict) and \"input\" in input_data:\n",
        "             # Cast the input_data to InputDict\n",
        "+            input_message = input_data.get(\"input\", \"\")\n",
        "+            if isinstance(input_message, BaseMessage):\n",
        "+                input_message = input_message.text()\n",
        "+            elif not isinstance(input_message, str):\n",
        "+                input_message = str(input_message)\n",
        "+\n",
        "             input_dict: InputDict = {\n",
        "-                \"input\": str(input_data.get(\"input\", \"\")),\n",
        "+                \"input\": input_message,\n",
        "                 \"chat_history\": input_data.get(\"chat_history\", []),\n",
        "             }\n",
        "             text_content = TextContent(\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/components/agents/agent.py",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "patch": "@@ -127,11 +127,15 @@ async def message_response(self) -> Message:\n             raise\n \n     async def get_memory_data(self):\n-        return (\n+        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\n+        messages = (\n             await MemoryComponent(**self.get_base_args())\n             .set(session_id=self.graph.session_id, order=\"Ascending\", n_messages=self.n_messages)\n             .retrieve_messages()\n         )\n+        return [\n+            message for message in messages if getattr(message, \"id\", None) != getattr(self.input_value, \"id\", None)\n+        ]\n \n     def get_llm(self):\n         if not isinstance(self.agent_llm, str):",
      "patch_lines": [
        "@@ -127,11 +127,15 @@ async def message_response(self) -> Message:\n",
        "             raise\n",
        " \n",
        "     async def get_memory_data(self):\n",
        "-        return (\n",
        "+        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\n",
        "+        messages = (\n",
        "             await MemoryComponent(**self.get_base_args())\n",
        "             .set(session_id=self.graph.session_id, order=\"Ascending\", n_messages=self.n_messages)\n",
        "             .retrieve_messages()\n",
        "         )\n",
        "+        return [\n",
        "+            message for message in messages if getattr(message, \"id\", None) != getattr(self.input_value, \"id\", None)\n",
        "+        ]\n",
        " \n",
        "     def get_llm(self):\n",
        "         if not isinstance(self.agent_llm, str):\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/components/datastax/astradb_tool.py",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -4,8 +4,8 @@\n \n from astrapy import Collection, DataAPIClient, Database\n from astrapy.admin import parse_api_endpoint\n-from langchain.pydantic_v1 import BaseModel, Field, create_model\n from langchain_core.tools import StructuredTool, Tool\n+from pydantic import BaseModel, Field, create_model\n \n from langflow.base.langchain_utilities.model import LCToolComponent\n from langflow.io import BoolInput, DictInput, HandleInput, IntInput, SecretStrInput, StrInput, TableInput",
      "patch_lines": [
        "@@ -4,8 +4,8 @@\n",
        " \n",
        " from astrapy import Collection, DataAPIClient, Database\n",
        " from astrapy.admin import parse_api_endpoint\n",
        "-from langchain.pydantic_v1 import BaseModel, Field, create_model\n",
        " from langchain_core.tools import StructuredTool, Tool\n",
        "+from pydantic import BaseModel, Field, create_model\n",
        " \n",
        " from langflow.base.langchain_utilities.model import LCToolComponent\n",
        " from langflow.io import BoolInput, DictInput, HandleInput, IntInput, SecretStrInput, StrInput, TableInput\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/Instagram Copywriter.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -2095,7 +2095,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -2095,7 +2095,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/Invoice Summarizer.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -1338,7 +1338,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -1338,7 +1338,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/Market Research.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -2187,7 +2187,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -2187,7 +2187,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/News Aggregator.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -1513,7 +1513,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -1513,7 +1513,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/Pok\u00e9dex Agent.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -1418,7 +1418,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -1418,7 +1418,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/Price Deal Finder.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -1777,7 +1777,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -1777,7 +1777,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/Research Agent.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -2692,7 +2692,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -2692,7 +2692,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/SaaS Pricing.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -1022,7 +1022,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -1022,7 +1022,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/Search agent.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -1132,7 +1132,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -1132,7 +1132,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/Sequential Tasks Agents.json",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "patch": "@@ -503,7 +503,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",\n@@ -1054,7 +1054,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",\n@@ -2398,7 +2398,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -503,7 +503,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n",
        "@@ -1054,7 +1054,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n",
        "@@ -2398,7 +2398,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/Simple Agent.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -1124,7 +1124,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -1124,7 +1124,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/Social Media Agent.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -1438,7 +1438,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -1438,7 +1438,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/Travel Planning Agents.json",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "patch": "@@ -1832,7 +1832,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",\n@@ -2376,7 +2376,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",\n@@ -2920,7 +2920,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -1832,7 +1832,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n",
        "@@ -2376,7 +2376,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n",
        "@@ -2920,7 +2920,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/initial_setup/starter_projects/Youtube Analysis.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -865,7 +865,7 @@\n                 \"show\": true,\n                 \"title_case\": false,\n                 \"type\": \"code\",\n-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n               },\n               \"handle_parsing_errors\": {\n                 \"_input_type\": \"BoolInput\",",
      "patch_lines": [
        "@@ -865,7 +865,7 @@\n",
        "                 \"show\": true,\n",
        "                 \"title_case\": false,\n",
        "                 \"type\": \"code\",\n",
        "-                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        return (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "+                \"value\": \"from langchain_core.tools import StructuredTool\\n\\nfrom langflow.base.agents.agent import LCToolsAgentComponent\\nfrom langflow.base.agents.events import ExceptionWithMessageError\\nfrom langflow.base.models.model_input_constants import (\\n    ALL_PROVIDER_FIELDS,\\n    MODEL_DYNAMIC_UPDATE_FIELDS,\\n    MODEL_PROVIDERS,\\n    MODEL_PROVIDERS_DICT,\\n    MODELS_METADATA,\\n)\\nfrom langflow.base.models.model_utils import get_model_name\\nfrom langflow.components.helpers.current_date import CurrentDateComponent\\nfrom langflow.components.helpers.memory import MemoryComponent\\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\\nfrom langflow.custom.custom_component.component import _get_component_toolkit\\nfrom langflow.custom.utils import update_component_build_config\\nfrom langflow.field_typing import Tool\\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output\\nfrom langflow.logging import logger\\nfrom langflow.schema.dotdict import dotdict\\nfrom langflow.schema.message import Message\\n\\n\\ndef set_advanced_true(component_input):\\n    component_input.advanced = True\\n    return component_input\\n\\n\\nMODEL_PROVIDERS_LIST = [\\\"Anthropic\\\", \\\"Google Generative AI\\\", \\\"Groq\\\", \\\"OpenAI\\\"]\\n\\n\\nclass AgentComponent(ToolCallingAgentComponent):\\n    display_name: str = \\\"Agent\\\"\\n    description: str = \\\"Define the agent's instructions, then enter a task to complete using tools.\\\"\\n    documentation: str = \\\"https://docs.langflow.org/agents\\\"\\n    icon = \\\"bot\\\"\\n    beta = False\\n    name = \\\"Agent\\\"\\n\\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\\n\\n    inputs = [\\n        DropdownInput(\\n            name=\\\"agent_llm\\\",\\n            display_name=\\\"Model Provider\\\",\\n            info=\\\"The provider of the language model that the agent will use to generate responses.\\\",\\n            options=[*MODEL_PROVIDERS_LIST, \\\"Custom\\\"],\\n            value=\\\"OpenAI\\\",\\n            real_time_refresh=True,\\n            input_types=[],\\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST] + [{\\\"icon\\\": \\\"brain\\\"}],\\n        ),\\n        *MODEL_PROVIDERS_DICT[\\\"OpenAI\\\"][\\\"inputs\\\"],\\n        MultilineInput(\\n            name=\\\"system_prompt\\\",\\n            display_name=\\\"Agent Instructions\\\",\\n            info=\\\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\\\",\\n            value=\\\"You are a helpful assistant that can use tools to answer questions and perform tasks.\\\",\\n            advanced=False,\\n        ),\\n        IntInput(\\n            name=\\\"n_messages\\\",\\n            display_name=\\\"Number of Chat History Messages\\\",\\n            value=100,\\n            info=\\\"Number of chat history messages to retrieve.\\\",\\n            advanced=True,\\n            show=True,\\n        ),\\n        *LCToolsAgentComponent._base_inputs,\\n        # removed memory inputs from agent component\\n        # *memory_inputs,\\n        BoolInput(\\n            name=\\\"add_current_date_tool\\\",\\n            display_name=\\\"Current Date\\\",\\n            advanced=True,\\n            info=\\\"If true, will add a tool to the agent that returns the current date.\\\",\\n            value=True,\\n        ),\\n    ]\\n    outputs = [Output(name=\\\"response\\\", display_name=\\\"Response\\\", method=\\\"message_response\\\")]\\n\\n    async def message_response(self) -> Message:\\n        try:\\n            # Get LLM model and validate\\n            llm_model, display_name = self.get_llm()\\n            if llm_model is None:\\n                msg = \\\"No language model selected. Please choose a model to proceed.\\\"\\n                raise ValueError(msg)\\n            self.model_name = get_model_name(llm_model, display_name=display_name)\\n\\n            # Get memory data\\n            self.chat_history = await self.get_memory_data()\\n            if isinstance(self.chat_history, Message):\\n                self.chat_history = [self.chat_history]\\n\\n            # Add current date tool if enabled\\n            if self.add_current_date_tool:\\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\\n                    self.tools = []\\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\\n                if not isinstance(current_date_tool, StructuredTool):\\n                    msg = \\\"CurrentDateComponent must be converted to a StructuredTool\\\"\\n                    raise TypeError(msg)\\n                self.tools.append(current_date_tool)\\n            # note the tools are not required to run the agent, hence the validation removed.\\n\\n            # Set up and run agent\\n            self.set(\\n                llm=llm_model,\\n                tools=self.tools or [],\\n                chat_history=self.chat_history,\\n                input_value=self.input_value,\\n                system_prompt=self.system_prompt,\\n            )\\n            agent = self.create_agent_runnable()\\n            return await self.run_agent(agent)\\n\\n        except (ValueError, TypeError, KeyError) as e:\\n            logger.error(f\\\"{type(e).__name__}: {e!s}\\\")\\n            raise\\n        except ExceptionWithMessageError as e:\\n            logger.error(f\\\"ExceptionWithMessageError occurred: {e}\\\")\\n            raise\\n        except Exception as e:\\n            logger.error(f\\\"Unexpected error: {e!s}\\\")\\n            raise\\n\\n    async def get_memory_data(self):\\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\\n        messages = (\\n            await MemoryComponent(**self.get_base_args())\\n            .set(session_id=self.graph.session_id, order=\\\"Ascending\\\", n_messages=self.n_messages)\\n            .retrieve_messages()\\n        )\\n        return [\\n            message for message in messages if getattr(message, \\\"id\\\", None) != getattr(self.input_value, \\\"id\\\", None)\\n        ]\\n\\n    def get_llm(self):\\n        if not isinstance(self.agent_llm, str):\\n            return self.agent_llm, None\\n\\n        try:\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if not provider_info:\\n                msg = f\\\"Invalid model provider: {self.agent_llm}\\\"\\n                raise ValueError(msg)\\n\\n            component_class = provider_info.get(\\\"component_class\\\")\\n            display_name = component_class.display_name\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\", \\\"\\\")\\n\\n            return self._build_llm_model(component_class, inputs, prefix), display_name\\n\\n        except Exception as e:\\n            logger.error(f\\\"Error building {self.agent_llm} language model: {e!s}\\\")\\n            msg = f\\\"Failed to initialize language model: {e!s}\\\"\\n            raise ValueError(msg) from e\\n\\n    def _build_llm_model(self, component, inputs, prefix=\\\"\\\"):\\n        model_kwargs = {}\\n        for input_ in inputs:\\n            if hasattr(self, f\\\"{prefix}{input_.name}\\\"):\\n                model_kwargs[input_.name] = getattr(self, f\\\"{prefix}{input_.name}\\\")\\n        return component.set(**model_kwargs).build_model()\\n\\n    def set_component_params(self, component):\\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n        if provider_info:\\n            inputs = provider_info.get(\\\"inputs\\\")\\n            prefix = provider_info.get(\\\"prefix\\\")\\n            model_kwargs = {input_.name: getattr(self, f\\\"{prefix}{input_.name}\\\") for input_ in inputs}\\n\\n            return component.set(**model_kwargs)\\n        return component\\n\\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\\n        \\\"\\\"\\\"Delete specified fields from build_config.\\\"\\\"\\\"\\n        for field in fields:\\n            build_config.pop(field, None)\\n\\n    def update_input_types(self, build_config: dotdict) -> dotdict:\\n        \\\"\\\"\\\"Update input types for all fields in build_config.\\\"\\\"\\\"\\n        for key, value in build_config.items():\\n            if isinstance(value, dict):\\n                if value.get(\\\"input_types\\\") is None:\\n                    build_config[key][\\\"input_types\\\"] = []\\n            elif hasattr(value, \\\"input_types\\\") and value.input_types is None:\\n                value.input_types = []\\n        return build_config\\n\\n    async def update_build_config(\\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\\n    ) -> dotdict:\\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\\n        # Existing logic for updating build_config\\n        if field_name in (\\\"agent_llm\\\",):\\n            build_config[\\\"agent_llm\\\"][\\\"value\\\"] = field_value\\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call the component class's update_build_config method\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n\\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\\n                provider: (\\n                    MODEL_PROVIDERS_DICT[provider][\\\"fields\\\"],\\n                    [\\n                        MODEL_PROVIDERS_DICT[other_provider][\\\"fields\\\"]\\n                        for other_provider in MODEL_PROVIDERS_DICT\\n                        if other_provider != provider\\n                    ],\\n                )\\n                for provider in MODEL_PROVIDERS_DICT\\n            }\\n            if field_value in provider_configs:\\n                fields_to_add, fields_to_delete = provider_configs[field_value]\\n\\n                # Delete fields from other providers\\n                for fields in fields_to_delete:\\n                    self.delete_fields(build_config, fields)\\n\\n                # Add provider-specific fields\\n                if field_value == \\\"OpenAI\\\" and not any(field in build_config for field in fields_to_add):\\n                    build_config.update(fields_to_add)\\n                else:\\n                    build_config.update(fields_to_add)\\n                # Reset input types for agent_llm\\n                build_config[\\\"agent_llm\\\"][\\\"input_types\\\"] = []\\n            elif field_value == \\\"Custom\\\":\\n                # Delete all provider fields\\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\\n                # Update with custom component\\n                custom_component = DropdownInput(\\n                    name=\\\"agent_llm\\\",\\n                    display_name=\\\"Language Model\\\",\\n                    options=[*sorted(MODEL_PROVIDERS), \\\"Custom\\\"],\\n                    value=\\\"Custom\\\",\\n                    real_time_refresh=True,\\n                    input_types=[\\\"LanguageModel\\\"],\\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\\n                    + [{\\\"icon\\\": \\\"brain\\\"}],\\n                )\\n                build_config.update({\\\"agent_llm\\\": custom_component.to_dict()})\\n            # Update input types for all fields\\n            build_config = self.update_input_types(build_config)\\n\\n            # Validate required keys\\n            default_keys = [\\n                \\\"code\\\",\\n                \\\"_type\\\",\\n                \\\"agent_llm\\\",\\n                \\\"tools\\\",\\n                \\\"input_value\\\",\\n                \\\"add_current_date_tool\\\",\\n                \\\"system_prompt\\\",\\n                \\\"agent_description\\\",\\n                \\\"max_iterations\\\",\\n                \\\"handle_parsing_errors\\\",\\n                \\\"verbose\\\",\\n            ]\\n            missing_keys = [key for key in default_keys if key not in build_config]\\n            if missing_keys:\\n                msg = f\\\"Missing required keys in build_config: {missing_keys}\\\"\\n                raise ValueError(msg)\\n        if (\\n            isinstance(self.agent_llm, str)\\n            and self.agent_llm in MODEL_PROVIDERS_DICT\\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\\n        ):\\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\\n            if provider_info:\\n                component_class = provider_info.get(\\\"component_class\\\")\\n                component_class = self.set_component_params(component_class)\\n                prefix = provider_info.get(\\\"prefix\\\")\\n                if component_class and hasattr(component_class, \\\"update_build_config\\\"):\\n                    # Call each component class's update_build_config method\\n                    # remove the prefix from the field_name\\n                    if isinstance(field_name, str) and isinstance(prefix, str):\\n                        field_name = field_name.replace(prefix, \\\"\\\")\\n                    build_config = await update_component_build_config(\\n                        component_class, build_config, field_value, \\\"model_name\\\"\\n                    )\\n        return dotdict({k: v.to_dict() if hasattr(v, \\\"to_dict\\\") else v for k, v in build_config.items()})\\n\\n    async def _get_tools(self) -> list[Tool]:\\n        component_toolkit = _get_component_toolkit()\\n        tools_names = self._build_tools_names()\\n        agent_description = self.get_tool_description()\\n        # TODO: Agent Description Depreciated Feature to be removed\\n        description = f\\\"{agent_description}{tools_names}\\\"\\n        tools = component_toolkit(component=self).get_tools(\\n            tool_name=\\\"Call_Agent\\\", tool_description=description, callbacks=self.get_langchain_callbacks()\\n        )\\n        if hasattr(self, \\\"tools_metadata\\\"):\\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\\n        return tools\\n\"\n",
        "               },\n",
        "               \"handle_parsing_errors\": {\n",
        "                 \"_input_type\": \"BoolInput\",\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/schema/data.py",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "patch": "@@ -13,7 +13,7 @@\n from pydantic import BaseModel, ConfigDict, model_serializer, model_validator\n \n from langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n-from langflow.utils.image import create_data_url\n+from langflow.utils.image import create_image_content_dict\n \n if TYPE_CHECKING:\n     from langflow.schema.dataframe import DataFrame\n@@ -171,11 +171,10 @@ def to_lc_message(\n             if files:\n                 from langflow.schema.image import get_file_paths\n \n-                contents = [{\"type\": \"text\", \"text\": text}]\n                 resolved_file_paths = get_file_paths(files)\n-                for file_path in resolved_file_paths:\n-                    image_url = create_data_url(file_path)\n-                    contents.append({\"type\": \"image_url\", \"image_url\": {\"url\": image_url}})\n+                contents = [create_image_content_dict(file_path) for file_path in resolved_file_paths]\n+                # add to the beginning of the list\n+                contents.insert(0, {\"type\": \"text\", \"text\": text})\n                 human_message = HumanMessage(content=contents)\n             else:\n                 human_message = HumanMessage(",
      "patch_lines": [
        "@@ -13,7 +13,7 @@\n",
        " from pydantic import BaseModel, ConfigDict, model_serializer, model_validator\n",
        " \n",
        " from langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n",
        "-from langflow.utils.image import create_data_url\n",
        "+from langflow.utils.image import create_image_content_dict\n",
        " \n",
        " if TYPE_CHECKING:\n",
        "     from langflow.schema.dataframe import DataFrame\n",
        "@@ -171,11 +171,10 @@ def to_lc_message(\n",
        "             if files:\n",
        "                 from langflow.schema.image import get_file_paths\n",
        " \n",
        "-                contents = [{\"type\": \"text\", \"text\": text}]\n",
        "                 resolved_file_paths = get_file_paths(files)\n",
        "-                for file_path in resolved_file_paths:\n",
        "-                    image_url = create_data_url(file_path)\n",
        "-                    contents.append({\"type\": \"image_url\", \"image_url\": {\"url\": image_url}})\n",
        "+                contents = [create_image_content_dict(file_path) for file_path in resolved_file_paths]\n",
        "+                # add to the beginning of the list\n",
        "+                contents.insert(0, {\"type\": \"text\", \"text\": text})\n",
        "                 human_message = HumanMessage(content=contents)\n",
        "             else:\n",
        "                 human_message = HumanMessage(\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/schema/image.py",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "patch": "@@ -22,7 +22,7 @@ def get_file_paths(files: list[str]):\n     storage_service = get_storage_service()\n     file_paths = []\n     for file in files:\n-        file_path = Path(file)\n+        file_path = Path(file.path) if hasattr(file, \"path\") and file.path else Path(file)\n         flow_id, file_name = str(file_path.parent), file_path.name\n         file_paths.append(storage_service.build_full_path(flow_id=flow_id, file_name=file_name))\n     return file_paths",
      "patch_lines": [
        "@@ -22,7 +22,7 @@ def get_file_paths(files: list[str]):\n",
        "     storage_service = get_storage_service()\n",
        "     file_paths = []\n",
        "     for file in files:\n",
        "-        file_path = Path(file)\n",
        "+        file_path = Path(file.path) if hasattr(file, \"path\") and file.path else Path(file)\n",
        "         flow_id, file_name = str(file_path.parent), file_path.name\n",
        "         file_paths.append(storage_service.build_full_path(flow_id=flow_id, file_name=file_name))\n",
        "     return file_paths\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/schema/message.py",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "patch": "@@ -30,7 +30,7 @@\n     MESSAGE_SENDER_NAME_USER,\n     MESSAGE_SENDER_USER,\n )\n-from langflow.utils.image import create_data_url\n+from langflow.utils.image import create_image_content_dict\n \n if TYPE_CHECKING:\n     from langflow.schema.dataframe import DataFrame\n@@ -206,8 +206,7 @@ def get_file_content_dicts(self):\n             if isinstance(file, Image):\n                 content_dicts.append(file.to_content_dict())\n             else:\n-                image_url = create_data_url(file)\n-                content_dicts.append({\"type\": \"image_url\", \"image_url\": {\"url\": image_url}})\n+                content_dicts.append(create_image_content_dict(file))\n         return content_dicts\n \n     def load_lc_prompt(self):",
      "patch_lines": [
        "@@ -30,7 +30,7 @@\n",
        "     MESSAGE_SENDER_NAME_USER,\n",
        "     MESSAGE_SENDER_USER,\n",
        " )\n",
        "-from langflow.utils.image import create_data_url\n",
        "+from langflow.utils.image import create_image_content_dict\n",
        " \n",
        " if TYPE_CHECKING:\n",
        "     from langflow.schema.dataframe import DataFrame\n",
        "@@ -206,8 +206,7 @@ def get_file_content_dicts(self):\n",
        "             if isinstance(file, Image):\n",
        "                 content_dicts.append(file.to_content_dict())\n",
        "             else:\n",
        "-                image_url = create_data_url(file)\n",
        "-                content_dicts.append({\"type\": \"image_url\", \"image_url\": {\"url\": image_url}})\n",
        "+                content_dicts.append(create_image_content_dict(file))\n",
        "         return content_dicts\n",
        " \n",
        "     def load_lc_prompt(self):\n"
      ]
    },
    {
      "path": "src/backend/base/langflow/utils/image.py",
      "status": "modified",
      "additions": 33,
      "deletions": 0,
      "patch": "@@ -1,5 +1,6 @@\n import base64\n import mimetypes\n+from functools import lru_cache\n from pathlib import Path\n \n \n@@ -67,3 +68,35 @@ def create_data_url(image_path: str | Path, mime_type: str | None = None) -> str\n         msg = f\"Failed to create data URL: {e}\"\n         raise type(e)(msg) from e\n     return f\"data:{mime_type};base64,{base64_data}\"\n+\n+\n+@lru_cache(maxsize=50)\n+def create_image_content_dict(image_path: str | Path, mime_type: str | None = None) -> dict:\n+    \"\"\"Create a content dictionary for multimodal inputs from an image file.\n+\n+    Args:\n+        image_path (str | Path): Path to the image file.\n+        mime_type (Optional[str], optional): MIME type of the image.\n+            If None, it will be guessed from the file extension.\n+\n+    Returns:\n+        dict: Content dictionary with type, source_type, data, and mime_type fields.\n+\n+    Raises:\n+        FileNotFoundError: If the image file does not exist.\n+        IOError: If there's an error reading the image file.\n+        ValueError: If the image path is empty or invalid.\n+    \"\"\"\n+    if not mime_type:\n+        mime_type = mimetypes.guess_type(str(image_path))[0]\n+        if not mime_type:\n+            msg = f\"Could not determine MIME type for: {image_path}\"\n+            raise ValueError(msg)\n+\n+    try:\n+        base64_data = convert_image_to_base64(image_path)\n+    except (OSError, FileNotFoundError, ValueError) as e:\n+        msg = f\"Failed to create image content dict: {e}\"\n+        raise type(e)(msg) from e\n+\n+    return {\"type\": \"image\", \"source_type\": \"url\", \"url\": f\"data:{mime_type};base64,{base64_data}\"}",
      "patch_lines": [
        "@@ -1,5 +1,6 @@\n",
        " import base64\n",
        " import mimetypes\n",
        "+from functools import lru_cache\n",
        " from pathlib import Path\n",
        " \n",
        " \n",
        "@@ -67,3 +68,35 @@ def create_data_url(image_path: str | Path, mime_type: str | None = None) -> str\n",
        "         msg = f\"Failed to create data URL: {e}\"\n",
        "         raise type(e)(msg) from e\n",
        "     return f\"data:{mime_type};base64,{base64_data}\"\n",
        "+\n",
        "+\n",
        "+@lru_cache(maxsize=50)\n",
        "+def create_image_content_dict(image_path: str | Path, mime_type: str | None = None) -> dict:\n",
        "+    \"\"\"Create a content dictionary for multimodal inputs from an image file.\n",
        "+\n",
        "+    Args:\n",
        "+        image_path (str | Path): Path to the image file.\n",
        "+        mime_type (Optional[str], optional): MIME type of the image.\n",
        "+            If None, it will be guessed from the file extension.\n",
        "+\n",
        "+    Returns:\n",
        "+        dict: Content dictionary with type, source_type, data, and mime_type fields.\n",
        "+\n",
        "+    Raises:\n",
        "+        FileNotFoundError: If the image file does not exist.\n",
        "+        IOError: If there's an error reading the image file.\n",
        "+        ValueError: If the image path is empty or invalid.\n",
        "+    \"\"\"\n",
        "+    if not mime_type:\n",
        "+        mime_type = mimetypes.guess_type(str(image_path))[0]\n",
        "+        if not mime_type:\n",
        "+            msg = f\"Could not determine MIME type for: {image_path}\"\n",
        "+            raise ValueError(msg)\n",
        "+\n",
        "+    try:\n",
        "+        base64_data = convert_image_to_base64(image_path)\n",
        "+    except (OSError, FileNotFoundError, ValueError) as e:\n",
        "+        msg = f\"Failed to create image content dict: {e}\"\n",
        "+        raise type(e)(msg) from e\n",
        "+\n",
        "+    return {\"type\": \"image\", \"source_type\": \"url\", \"url\": f\"data:{mime_type};base64,{base64_data}\"}\n"
      ]
    },
    {
      "path": "src/backend/tests/unit/schema/test_schema_data.py",
      "status": "modified",
      "additions": 13,
      "deletions": 6,
      "patch": "@@ -39,9 +39,10 @@ def test_data_to_message_with_image(self, sample_image):\n         assert message.content[0] == {\"type\": \"text\", \"text\": \"Check out this image\"}\n \n         # Check image content\n-        assert message.content[1][\"type\"] == \"image_url\"\n-        assert \"url\" in message.content[1][\"image_url\"]\n-        assert message.content[1][\"image_url\"][\"url\"].startswith(\"data:image/png;base64,\")\n+        assert message.content[1][\"type\"] == \"image\"\n+        assert message.content[1][\"source_type\"] == \"url\"\n+        assert \"url\" in message.content[1]\n+        assert message.content[1][\"url\"].startswith(\"data:image/png;base64,\")\n \n     def test_data_to_message_with_multiple_images(self, sample_image, tmp_path):\n         \"\"\"Test conversion of Data to Message with multiple images.\"\"\"\n@@ -66,9 +67,15 @@ def test_data_to_message_with_multiple_images(self, sample_image, tmp_path):\n         assert message.content[0][\"type\"] == \"text\"\n \n         # Check both images\n-        assert message.content[1][\"type\"] == \"image_url\"\n-        assert message.content[2][\"type\"] == \"image_url\"\n-        assert all(content[\"image_url\"][\"url\"].startswith(\"data:image/png;base64,\") for content in message.content[1:])\n+        assert message.content[1][\"type\"] == \"image\"\n+        assert message.content[1][\"source_type\"] == \"url\"\n+        assert \"url\" in message.content[1]\n+        assert message.content[1][\"url\"].startswith(\"data:image/png;base64,\")\n+\n+        assert message.content[2][\"type\"] == \"image\"\n+        assert message.content[2][\"source_type\"] == \"url\"\n+        assert \"url\" in message.content[2]\n+        assert message.content[2][\"url\"].startswith(\"data:image/png;base64,\")\n \n     def test_data_to_message_ai_response(self):\n         \"\"\"Test conversion of Data to AI Message.\"\"\"",
      "patch_lines": [
        "@@ -39,9 +39,10 @@ def test_data_to_message_with_image(self, sample_image):\n",
        "         assert message.content[0] == {\"type\": \"text\", \"text\": \"Check out this image\"}\n",
        " \n",
        "         # Check image content\n",
        "-        assert message.content[1][\"type\"] == \"image_url\"\n",
        "-        assert \"url\" in message.content[1][\"image_url\"]\n",
        "-        assert message.content[1][\"image_url\"][\"url\"].startswith(\"data:image/png;base64,\")\n",
        "+        assert message.content[1][\"type\"] == \"image\"\n",
        "+        assert message.content[1][\"source_type\"] == \"url\"\n",
        "+        assert \"url\" in message.content[1]\n",
        "+        assert message.content[1][\"url\"].startswith(\"data:image/png;base64,\")\n",
        " \n",
        "     def test_data_to_message_with_multiple_images(self, sample_image, tmp_path):\n",
        "         \"\"\"Test conversion of Data to Message with multiple images.\"\"\"\n",
        "@@ -66,9 +67,15 @@ def test_data_to_message_with_multiple_images(self, sample_image, tmp_path):\n",
        "         assert message.content[0][\"type\"] == \"text\"\n",
        " \n",
        "         # Check both images\n",
        "-        assert message.content[1][\"type\"] == \"image_url\"\n",
        "-        assert message.content[2][\"type\"] == \"image_url\"\n",
        "-        assert all(content[\"image_url\"][\"url\"].startswith(\"data:image/png;base64,\") for content in message.content[1:])\n",
        "+        assert message.content[1][\"type\"] == \"image\"\n",
        "+        assert message.content[1][\"source_type\"] == \"url\"\n",
        "+        assert \"url\" in message.content[1]\n",
        "+        assert message.content[1][\"url\"].startswith(\"data:image/png;base64,\")\n",
        "+\n",
        "+        assert message.content[2][\"type\"] == \"image\"\n",
        "+        assert message.content[2][\"source_type\"] == \"url\"\n",
        "+        assert \"url\" in message.content[2]\n",
        "+        assert message.content[2][\"url\"].startswith(\"data:image/png;base64,\")\n",
        " \n",
        "     def test_data_to_message_ai_response(self):\n",
        "         \"\"\"Test conversion of Data to AI Message.\"\"\"\n"
      ]
    },
    {
      "path": "src/backend/tests/unit/schema/test_schema_message.py",
      "status": "modified",
      "additions": 10,
      "deletions": 6,
      "patch": "@@ -65,6 +65,7 @@ def test_message_from_human_text():\n     lc_message = message.to_lc_message()\n \n     assert isinstance(lc_message, HumanMessage)\n+    assert isinstance(lc_message.content, str)\n     assert lc_message.content == text\n \n \n@@ -94,9 +95,10 @@ def test_message_with_single_image(sample_image):\n     assert lc_message.content[0] == {\"type\": \"text\", \"text\": text}\n \n     # Check image content\n-    assert lc_message.content[1][\"type\"] == \"image_url\"\n-    assert \"url\" in lc_message.content[1][\"image_url\"]\n-    assert lc_message.content[1][\"image_url\"][\"url\"].startswith(\"data:image/png;base64,\")\n+    assert lc_message.content[1][\"type\"] == \"image\"\n+    assert lc_message.content[1][\"source_type\"] == \"url\"\n+    assert \"url\" in lc_message.content[1]\n+    assert lc_message.content[1][\"url\"].startswith(\"data:image/png;base64,\")\n \n \n def test_message_with_multiple_images(sample_image, langflow_cache_dir):\n@@ -129,7 +131,10 @@ def test_message_with_multiple_images(sample_image, langflow_cache_dir):\n \n     # Check both images\n     assert all(\n-        content[\"type\"] == \"image_url\" and content[\"image_url\"][\"url\"].startswith(\"data:image/png;base64,\")\n+        content[\"type\"] == \"image\"\n+        and content[\"source_type\"] == \"url\"\n+        and \"url\" in content\n+        and content[\"url\"].startswith(\"data:image/png;base64,\")\n         for content in lc_message.content[1:]\n     )\n \n@@ -169,10 +174,9 @@ def test_message_serialization():\n def test_message_to_lc_without_sender():\n     \"\"\"Test converting a message without sender to langchain message.\"\"\"\n     message = Message(text=\"Test message\")\n-    # When no sender is specified, it defaults to HumanMessage\n+    # When no sender is specified, it defaults to AIMessage\n     lc_message = message.to_lc_message()\n     assert isinstance(lc_message, HumanMessage)\n-    assert lc_message.content == \"Test message\"\n \n \n def test_timestamp_serialization():",
      "patch_lines": [
        "@@ -65,6 +65,7 @@ def test_message_from_human_text():\n",
        "     lc_message = message.to_lc_message()\n",
        " \n",
        "     assert isinstance(lc_message, HumanMessage)\n",
        "+    assert isinstance(lc_message.content, str)\n",
        "     assert lc_message.content == text\n",
        " \n",
        " \n",
        "@@ -94,9 +95,10 @@ def test_message_with_single_image(sample_image):\n",
        "     assert lc_message.content[0] == {\"type\": \"text\", \"text\": text}\n",
        " \n",
        "     # Check image content\n",
        "-    assert lc_message.content[1][\"type\"] == \"image_url\"\n",
        "-    assert \"url\" in lc_message.content[1][\"image_url\"]\n",
        "-    assert lc_message.content[1][\"image_url\"][\"url\"].startswith(\"data:image/png;base64,\")\n",
        "+    assert lc_message.content[1][\"type\"] == \"image\"\n",
        "+    assert lc_message.content[1][\"source_type\"] == \"url\"\n",
        "+    assert \"url\" in lc_message.content[1]\n",
        "+    assert lc_message.content[1][\"url\"].startswith(\"data:image/png;base64,\")\n",
        " \n",
        " \n",
        " def test_message_with_multiple_images(sample_image, langflow_cache_dir):\n",
        "@@ -129,7 +131,10 @@ def test_message_with_multiple_images(sample_image, langflow_cache_dir):\n",
        " \n",
        "     # Check both images\n",
        "     assert all(\n",
        "-        content[\"type\"] == \"image_url\" and content[\"image_url\"][\"url\"].startswith(\"data:image/png;base64,\")\n",
        "+        content[\"type\"] == \"image\"\n",
        "+        and content[\"source_type\"] == \"url\"\n",
        "+        and \"url\" in content\n",
        "+        and content[\"url\"].startswith(\"data:image/png;base64,\")\n",
        "         for content in lc_message.content[1:]\n",
        "     )\n",
        " \n",
        "@@ -169,10 +174,9 @@ def test_message_serialization():\n",
        " def test_message_to_lc_without_sender():\n",
        "     \"\"\"Test converting a message without sender to langchain message.\"\"\"\n",
        "     message = Message(text=\"Test message\")\n",
        "-    # When no sender is specified, it defaults to HumanMessage\n",
        "+    # When no sender is specified, it defaults to AIMessage\n",
        "     lc_message = message.to_lc_message()\n",
        "     assert isinstance(lc_message, HumanMessage)\n",
        "-    assert lc_message.content == \"Test message\"\n",
        " \n",
        " \n",
        " def test_timestamp_serialization():\n"
      ]
    },
    {
      "path": "src/backend/tests/unit/utils/test_image_utils.py",
      "status": "modified",
      "additions": 37,
      "deletions": 1,
      "patch": "@@ -1,7 +1,7 @@\n import base64\n \n import pytest\n-from langflow.utils.image import convert_image_to_base64, create_data_url\n+from langflow.utils.image import convert_image_to_base64, create_data_url, create_image_content_dict\n \n \n @pytest.fixture\n@@ -70,3 +70,39 @@ def test_create_data_url_unrecognized_extension(tmp_path):\n     invalid_file.touch()\n     with pytest.raises(ValueError, match=\"Could not determine MIME type\"):\n         create_data_url(invalid_file)\n+\n+\n+def test_create_image_content_dict_success(sample_image):\n+    \"\"\"Test successful creation of image content dict.\"\"\"\n+    content_dict = create_image_content_dict(sample_image)\n+    assert content_dict[\"type\"] == \"image\"\n+    assert content_dict[\"source_type\"] == \"url\"\n+    assert \"url\" in content_dict\n+    assert content_dict[\"url\"].startswith(\"data:image/png;base64,\")\n+    # Verify the base64 part is valid\n+    base64_part = content_dict[\"url\"].split(\",\")[1]\n+    assert base64.b64decode(base64_part)\n+\n+\n+def test_create_image_content_dict_with_custom_mime(sample_image):\n+    \"\"\"Test creation of image content dict with custom MIME type.\"\"\"\n+    custom_mime = \"image/custom\"\n+    content_dict = create_image_content_dict(sample_image, mime_type=custom_mime)\n+    assert content_dict[\"type\"] == \"image\"\n+    assert content_dict[\"source_type\"] == \"url\"\n+    assert \"url\" in content_dict\n+    assert content_dict[\"url\"].startswith(f\"data:{custom_mime};base64,\")\n+\n+\n+def test_create_image_content_dict_invalid_file():\n+    \"\"\"Test creation of image content dict with invalid file.\"\"\"\n+    with pytest.raises(FileNotFoundError):\n+        create_image_content_dict(\"nonexistent.jpg\")\n+\n+\n+def test_create_image_content_dict_unrecognized_extension(tmp_path):\n+    \"\"\"Test creation of image content dict with unrecognized file extension.\"\"\"\n+    invalid_file = tmp_path / \"test.unknown\"\n+    invalid_file.touch()\n+    with pytest.raises(ValueError, match=\"Could not determine MIME type\"):\n+        create_image_content_dict(invalid_file)",
      "patch_lines": [
        "@@ -1,7 +1,7 @@\n",
        " import base64\n",
        " \n",
        " import pytest\n",
        "-from langflow.utils.image import convert_image_to_base64, create_data_url\n",
        "+from langflow.utils.image import convert_image_to_base64, create_data_url, create_image_content_dict\n",
        " \n",
        " \n",
        " @pytest.fixture\n",
        "@@ -70,3 +70,39 @@ def test_create_data_url_unrecognized_extension(tmp_path):\n",
        "     invalid_file.touch()\n",
        "     with pytest.raises(ValueError, match=\"Could not determine MIME type\"):\n",
        "         create_data_url(invalid_file)\n",
        "+\n",
        "+\n",
        "+def test_create_image_content_dict_success(sample_image):\n",
        "+    \"\"\"Test successful creation of image content dict.\"\"\"\n",
        "+    content_dict = create_image_content_dict(sample_image)\n",
        "+    assert content_dict[\"type\"] == \"image\"\n",
        "+    assert content_dict[\"source_type\"] == \"url\"\n",
        "+    assert \"url\" in content_dict\n",
        "+    assert content_dict[\"url\"].startswith(\"data:image/png;base64,\")\n",
        "+    # Verify the base64 part is valid\n",
        "+    base64_part = content_dict[\"url\"].split(\",\")[1]\n",
        "+    assert base64.b64decode(base64_part)\n",
        "+\n",
        "+\n",
        "+def test_create_image_content_dict_with_custom_mime(sample_image):\n",
        "+    \"\"\"Test creation of image content dict with custom MIME type.\"\"\"\n",
        "+    custom_mime = \"image/custom\"\n",
        "+    content_dict = create_image_content_dict(sample_image, mime_type=custom_mime)\n",
        "+    assert content_dict[\"type\"] == \"image\"\n",
        "+    assert content_dict[\"source_type\"] == \"url\"\n",
        "+    assert \"url\" in content_dict\n",
        "+    assert content_dict[\"url\"].startswith(f\"data:{custom_mime};base64,\")\n",
        "+\n",
        "+\n",
        "+def test_create_image_content_dict_invalid_file():\n",
        "+    \"\"\"Test creation of image content dict with invalid file.\"\"\"\n",
        "+    with pytest.raises(FileNotFoundError):\n",
        "+        create_image_content_dict(\"nonexistent.jpg\")\n",
        "+\n",
        "+\n",
        "+def test_create_image_content_dict_unrecognized_extension(tmp_path):\n",
        "+    \"\"\"Test creation of image content dict with unrecognized file extension.\"\"\"\n",
        "+    invalid_file = tmp_path / \"test.unknown\"\n",
        "+    invalid_file.touch()\n",
        "+    with pytest.raises(ValueError, match=\"Could not determine MIME type\"):\n",
        "+        create_image_content_dict(invalid_file)\n"
      ]
    },
    {
      "path": "src/frontend/tests/extended/regression/general-bugs-agent-sum-duplicate-message-playground.spec.ts",
      "status": "added",
      "additions": 83,
      "deletions": 0,
      "patch": "@@ -0,0 +1,83 @@\n+import { expect, test } from \"@playwright/test\";\n+import dotenv from \"dotenv\";\n+import path from \"path\";\n+import { awaitBootstrapTest } from \"../../utils/await-bootstrap-test\";\n+\n+test(\n+  \"user must not experience message duplication in mathematical expressions with agent component\",\n+  { tag: [\"@release\", \"@components\", \"@workspace\"] },\n+  async ({ page }) => {\n+    test.skip(\n+      !process?.env?.ANTHROPIC_API_KEY,\n+      \"ANTHROPIC_API_KEY required to run this test\",\n+    );\n+\n+    if (!process.env.CI) {\n+      dotenv.config({ path: path.resolve(__dirname, \"../../.env\") });\n+    }\n+    await awaitBootstrapTest(page);\n+\n+    await page.getByTestId(\"side_nav_options_all-templates\").click();\n+    await page.getByRole(\"heading\", { name: \"Simple Agent\" }).first().click();\n+\n+    await page.getByTestId(\"value-dropdown-dropdown_str_agent_llm\").click();\n+\n+    await page.waitForTimeout(200);\n+\n+    await page.getByText(\"Anthropic\").last().click();\n+\n+    await page\n+      .getByTestId(\"popover-anchor-input-api_key\")\n+      .fill(process.env.ANTHROPIC_API_KEY || \"\");\n+\n+    await page.getByTestId(\"playground-btn-flow-io\").click();\n+\n+    await page.waitForSelector('[data-testid=\"input-chat-playground\"]', {\n+      timeout: 100000,\n+    });\n+\n+    // Test simple math expression\n+    await page.getByTestId(\"input-chat-playground\").fill(\"2+2\");\n+\n+    await page.waitForSelector('[data-testid=\"button-send\"]', {\n+      timeout: 100000,\n+    });\n+\n+    await page.getByTestId(\"button-send\").click();\n+    // Wait for response completion\n+    await page.waitForSelector(\n+      '[data-testid=\"header-icon\"] svg[data-testid=\"icon-Check\"]',\n+      {\n+        timeout: 30000,\n+      },\n+    );\n+\n+    // Click on the execution section to expand and reveal the JSON blocks\n+    await page.locator('[data-testid=\"header-icon\"]').first().click();\n+\n+    // Wait for the JSON code blocks to appear after clicking\n+    await page.waitForSelector('[data-testid=\"chat-code-tab\"]', {\n+      timeout: 10000,\n+    });\n+\n+    // Get all the JSON code content to check both input and output\n+    const codeBlocks = await page\n+      .locator('[data-testid=\"chat-code-tab\"] code.language-json')\n+      .allTextContents();\n+\n+    // First code block should contain the input expression\n+    const inputJson = codeBlocks[0];\n+    expect(inputJson).toContain('\"expression\": \"2+2\"');\n+\n+    // Verify the input is NOT duplicated (should not contain \"2+22+2\")\n+    expect(inputJson).not.toContain('\"expression\": \"2+22+2\"');\n+    expect(inputJson).not.toContain('\"expression\": \"22+2\"');\n+\n+    // Second code block should contain the output result\n+    const outputJson = codeBlocks[1];\n+    expect(outputJson).toContain('\"result\": \"4\"');\n+\n+    // Ensure the result is not 26 (which would be 2+22+2)\n+    expect(outputJson).not.toContain('\"result\": \"26\"');\n+  },\n+);",
      "patch_lines": [
        "@@ -0,0 +1,83 @@\n",
        "+import { expect, test } from \"@playwright/test\";\n",
        "+import dotenv from \"dotenv\";\n",
        "+import path from \"path\";\n",
        "+import { awaitBootstrapTest } from \"../../utils/await-bootstrap-test\";\n",
        "+\n",
        "+test(\n",
        "+  \"user must not experience message duplication in mathematical expressions with agent component\",\n",
        "+  { tag: [\"@release\", \"@components\", \"@workspace\"] },\n",
        "+  async ({ page }) => {\n",
        "+    test.skip(\n",
        "+      !process?.env?.ANTHROPIC_API_KEY,\n",
        "+      \"ANTHROPIC_API_KEY required to run this test\",\n",
        "+    );\n",
        "+\n",
        "+    if (!process.env.CI) {\n",
        "+      dotenv.config({ path: path.resolve(__dirname, \"../../.env\") });\n",
        "+    }\n",
        "+    await awaitBootstrapTest(page);\n",
        "+\n",
        "+    await page.getByTestId(\"side_nav_options_all-templates\").click();\n",
        "+    await page.getByRole(\"heading\", { name: \"Simple Agent\" }).first().click();\n",
        "+\n",
        "+    await page.getByTestId(\"value-dropdown-dropdown_str_agent_llm\").click();\n",
        "+\n",
        "+    await page.waitForTimeout(200);\n",
        "+\n",
        "+    await page.getByText(\"Anthropic\").last().click();\n",
        "+\n",
        "+    await page\n",
        "+      .getByTestId(\"popover-anchor-input-api_key\")\n",
        "+      .fill(process.env.ANTHROPIC_API_KEY || \"\");\n",
        "+\n",
        "+    await page.getByTestId(\"playground-btn-flow-io\").click();\n",
        "+\n",
        "+    await page.waitForSelector('[data-testid=\"input-chat-playground\"]', {\n",
        "+      timeout: 100000,\n",
        "+    });\n",
        "+\n",
        "+    // Test simple math expression\n",
        "+    await page.getByTestId(\"input-chat-playground\").fill(\"2+2\");\n",
        "+\n",
        "+    await page.waitForSelector('[data-testid=\"button-send\"]', {\n",
        "+      timeout: 100000,\n",
        "+    });\n",
        "+\n",
        "+    await page.getByTestId(\"button-send\").click();\n",
        "+    // Wait for response completion\n",
        "+    await page.waitForSelector(\n",
        "+      '[data-testid=\"header-icon\"] svg[data-testid=\"icon-Check\"]',\n",
        "+      {\n",
        "+        timeout: 30000,\n",
        "+      },\n",
        "+    );\n",
        "+\n",
        "+    // Click on the execution section to expand and reveal the JSON blocks\n",
        "+    await page.locator('[data-testid=\"header-icon\"]').first().click();\n",
        "+\n",
        "+    // Wait for the JSON code blocks to appear after clicking\n",
        "+    await page.waitForSelector('[data-testid=\"chat-code-tab\"]', {\n",
        "+      timeout: 10000,\n",
        "+    });\n",
        "+\n",
        "+    // Get all the JSON code content to check both input and output\n",
        "+    const codeBlocks = await page\n",
        "+      .locator('[data-testid=\"chat-code-tab\"] code.language-json')\n",
        "+      .allTextContents();\n",
        "+\n",
        "+    // First code block should contain the input expression\n",
        "+    const inputJson = codeBlocks[0];\n",
        "+    expect(inputJson).toContain('\"expression\": \"2+2\"');\n",
        "+\n",
        "+    // Verify the input is NOT duplicated (should not contain \"2+22+2\")\n",
        "+    expect(inputJson).not.toContain('\"expression\": \"2+22+2\"');\n",
        "+    expect(inputJson).not.toContain('\"expression\": \"22+2\"');\n",
        "+\n",
        "+    // Second code block should contain the output result\n",
        "+    const outputJson = codeBlocks[1];\n",
        "+    expect(outputJson).toContain('\"result\": \"4\"');\n",
        "+\n",
        "+    // Ensure the result is not 26 (which would be 2+22+2)\n",
        "+    expect(outputJson).not.toContain('\"result\": \"26\"');\n",
        "+  },\n",
        "+);\n"
      ]
    }
  ]
}
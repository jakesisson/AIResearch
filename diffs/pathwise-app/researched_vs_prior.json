{
  "project": "Research Data/pathwise-app",
  "repo": "Dtano17/pathwise_app",
  "prior_commit": "24278341077550d220fac6044f520646522fc799",
  "researched_commit": "7e4670094d0cd943e5eac928352881126862a350",
  "compare_url": "https://github.com/Dtano17/pathwise_app/compare/24278341077550d220fac6044f520646522fc799...7e4670094d0cd943e5eac928352881126862a350",
  "ahead_by": 1,
  "behind_by": 0,
  "changed_files": [
    {
      "path": "client/src/pages/MainApp.tsx",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "patch": "@@ -299,6 +299,29 @@ export default function MainApp({\n   // Sign-in dialog state\n   const [showSignInDialog, setShowSignInDialog] = useState(false);\n \n+  // Profile completion for OAuth new users\n+  const [showProfileCompletion, setShowProfileCompletion] = useState(false);\n+  const [oauthUserId, setOauthUserId] = useState<string | null>(null);\n+\n+  // Check for OAuth new user redirect\n+  useEffect(() => {\n+    const urlParams = new URLSearchParams(window.location.search);\n+    const isNewUser = urlParams.get('newUser') === 'true';\n+    const userId = urlParams.get('userId');\n+\n+    if (isNewUser && userId) {\n+      toast({\n+        title: \"Welcome! \ud83c\udf89\",\n+        description: \"Your account has been created. Complete your profile to get personalized recommendations!\",\n+        duration: 5000,\n+      });\n+      setOauthUserId(userId);\n+      setShowProfileCompletion(true);\n+      // Clean up URL\n+      window.history.replaceState({}, '', window.location.pathname);\n+    }\n+  }, [toast]);\n+\n   // Sign-in gate component for restricted features\n   const SignInGate = ({ children, feature }: { children: React.ReactNode; feature: string }) => {\n     if (isAuthenticated) {",
      "patch_lines": [
        "@@ -299,6 +299,29 @@ export default function MainApp({\n",
        "   // Sign-in dialog state\n",
        "   const [showSignInDialog, setShowSignInDialog] = useState(false);\n",
        " \n",
        "+  // Profile completion for OAuth new users\n",
        "+  const [showProfileCompletion, setShowProfileCompletion] = useState(false);\n",
        "+  const [oauthUserId, setOauthUserId] = useState<string | null>(null);\n",
        "+\n",
        "+  // Check for OAuth new user redirect\n",
        "+  useEffect(() => {\n",
        "+    const urlParams = new URLSearchParams(window.location.search);\n",
        "+    const isNewUser = urlParams.get('newUser') === 'true';\n",
        "+    const userId = urlParams.get('userId');\n",
        "+\n",
        "+    if (isNewUser && userId) {\n",
        "+      toast({\n",
        "+        title: \"Welcome! \ud83c\udf89\",\n",
        "+        description: \"Your account has been created. Complete your profile to get personalized recommendations!\",\n",
        "+        duration: 5000,\n",
        "+      });\n",
        "+      setOauthUserId(userId);\n",
        "+      setShowProfileCompletion(true);\n",
        "+      // Clean up URL\n",
        "+      window.history.replaceState({}, '', window.location.pathname);\n",
        "+    }\n",
        "+  }, [toast]);\n",
        "+\n",
        "   // Sign-in gate component for restricted features\n",
        "   const SignInGate = ({ children, feature }: { children: React.ReactNode; feature: string }) => {\n",
        "     if (isAuthenticated) {\n"
      ]
    },
    {
      "path": "server/multiProviderAuth.ts",
      "status": "modified",
      "additions": 31,
      "deletions": 10,
      "patch": "@@ -43,6 +43,7 @@ interface OAuthUser {\n   firstName?: string;\n   lastName?: string;\n   profileImageUrl?: string;\n+  isNewUser?: boolean;\n }\n \n // Setup multi-provider OAuth strategies\n@@ -64,8 +65,9 @@ export async function setupMultiProviderAuth(app: Express) {\n \n         // Check if this Google account is already linked\n         let authIdentity = await storage.getAuthIdentity('google', profile.id);\n-        \n+\n         let user;\n+        let isNewUser = false;\n         if (authIdentity) {\n           // User already exists with this Google account\n           user = await storage.getUser(authIdentity.userId);\n@@ -74,14 +76,14 @@ export async function setupMultiProviderAuth(app: Express) {\n           if (email) {\n             user = await storage.getUserByEmail(email);\n           }\n-          \n+\n           if (!user) {\n             // Generate username from email or use Google ID as fallback\n             let username = profile.id; // fallback to Google ID\n             if (email && typeof email === 'string') {\n               username = email.split('@')[0].replace(/[^a-zA-Z0-9_]/g, '_');\n             }\n-            \n+\n             // Create new user\n             user = await storage.upsertUser({\n               username: username,\n@@ -91,6 +93,7 @@ export async function setupMultiProviderAuth(app: Express) {\n               lastName: lastName || undefined,\n               profileImageUrl: profileImageUrl || undefined,\n             });\n+            isNewUser = true;\n           }\n \n           // Link Google account to user\n@@ -121,6 +124,7 @@ export async function setupMultiProviderAuth(app: Express) {\n             firstName: user.firstName || undefined,\n             lastName: user.lastName || undefined,\n             profileImageUrl: user.profileImageUrl || undefined,\n+            isNewUser\n           };\n \n           return done(null, oauthUser);\n@@ -151,8 +155,9 @@ export async function setupMultiProviderAuth(app: Express) {\n \n         // Check if this Facebook account is already linked\n         let authIdentity = await storage.getAuthIdentity('facebook', profile.id);\n-        \n+\n         let user;\n+        let isNewUser = false;\n         if (authIdentity) {\n           // User already exists with this Facebook account\n           user = await storage.getUser(authIdentity.userId);\n@@ -161,14 +166,14 @@ export async function setupMultiProviderAuth(app: Express) {\n           if (email) {\n             user = await storage.getUserByEmail(email);\n           }\n-          \n+\n           if (!user) {\n             // Generate username from email or use Facebook ID as fallback\n             let username = profile.id; // fallback to Facebook ID\n             if (email && typeof email === 'string') {\n               username = email.split('@')[0].replace(/[^a-zA-Z0-9_]/g, '_');\n             }\n-            \n+\n             // Create new user\n             user = await storage.upsertUser({\n               username: username,\n@@ -178,6 +183,7 @@ export async function setupMultiProviderAuth(app: Express) {\n               lastName: lastName || undefined,\n               profileImageUrl: profileImageUrl || undefined,\n             });\n+            isNewUser = true;\n           }\n \n           // Link Facebook account to user\n@@ -208,6 +214,7 @@ export async function setupMultiProviderAuth(app: Express) {\n             firstName: user.firstName || undefined,\n             lastName: user.lastName || undefined,\n             profileImageUrl: user.profileImageUrl || undefined,\n+            isNewUser\n           };\n \n           return done(null, oauthUser);\n@@ -396,8 +403,15 @@ export async function setupMultiProviderAuth(app: Express) {\n   app.get('/api/auth/google/callback',\n     passport.authenticate('google', { failureRedirect: '/?auth=error' }),\n     (req, res) => {\n-      // Successful authentication, redirect to app\n-      res.redirect('/?auth=success');\n+      // Check if this is a new user who needs profile completion\n+      const user = req.user as OAuthUser;\n+      if (user?.isNewUser) {\n+        // New user - redirect to profile completion\n+        res.redirect(`/?auth=success&newUser=true&userId=${user.id}`);\n+      } else {\n+        // Existing user - redirect to app\n+        res.redirect('/?auth=success');\n+      }\n     }\n   );\n \n@@ -409,8 +423,15 @@ export async function setupMultiProviderAuth(app: Express) {\n   app.get('/api/auth/facebook/callback',\n     passport.authenticate('facebook', { failureRedirect: '/?auth=error' }),\n     (req, res) => {\n-      // Successful authentication, redirect to app\n-      res.redirect('/?auth=success');\n+      // Check if this is a new user who needs profile completion\n+      const user = req.user as OAuthUser;\n+      if (user?.isNewUser) {\n+        // New user - redirect to profile completion\n+        res.redirect(`/?auth=success&newUser=true&userId=${user.id}`);\n+      } else {\n+        // Existing user - redirect to app\n+        res.redirect('/?auth=success');\n+      }\n     }\n   );\n ",
      "patch_lines": [
        "@@ -43,6 +43,7 @@ interface OAuthUser {\n",
        "   firstName?: string;\n",
        "   lastName?: string;\n",
        "   profileImageUrl?: string;\n",
        "+  isNewUser?: boolean;\n",
        " }\n",
        " \n",
        " // Setup multi-provider OAuth strategies\n",
        "@@ -64,8 +65,9 @@ export async function setupMultiProviderAuth(app: Express) {\n",
        " \n",
        "         // Check if this Google account is already linked\n",
        "         let authIdentity = await storage.getAuthIdentity('google', profile.id);\n",
        "-        \n",
        "+\n",
        "         let user;\n",
        "+        let isNewUser = false;\n",
        "         if (authIdentity) {\n",
        "           // User already exists with this Google account\n",
        "           user = await storage.getUser(authIdentity.userId);\n",
        "@@ -74,14 +76,14 @@ export async function setupMultiProviderAuth(app: Express) {\n",
        "           if (email) {\n",
        "             user = await storage.getUserByEmail(email);\n",
        "           }\n",
        "-          \n",
        "+\n",
        "           if (!user) {\n",
        "             // Generate username from email or use Google ID as fallback\n",
        "             let username = profile.id; // fallback to Google ID\n",
        "             if (email && typeof email === 'string') {\n",
        "               username = email.split('@')[0].replace(/[^a-zA-Z0-9_]/g, '_');\n",
        "             }\n",
        "-            \n",
        "+\n",
        "             // Create new user\n",
        "             user = await storage.upsertUser({\n",
        "               username: username,\n",
        "@@ -91,6 +93,7 @@ export async function setupMultiProviderAuth(app: Express) {\n",
        "               lastName: lastName || undefined,\n",
        "               profileImageUrl: profileImageUrl || undefined,\n",
        "             });\n",
        "+            isNewUser = true;\n",
        "           }\n",
        " \n",
        "           // Link Google account to user\n",
        "@@ -121,6 +124,7 @@ export async function setupMultiProviderAuth(app: Express) {\n",
        "             firstName: user.firstName || undefined,\n",
        "             lastName: user.lastName || undefined,\n",
        "             profileImageUrl: user.profileImageUrl || undefined,\n",
        "+            isNewUser\n",
        "           };\n",
        " \n",
        "           return done(null, oauthUser);\n",
        "@@ -151,8 +155,9 @@ export async function setupMultiProviderAuth(app: Express) {\n",
        " \n",
        "         // Check if this Facebook account is already linked\n",
        "         let authIdentity = await storage.getAuthIdentity('facebook', profile.id);\n",
        "-        \n",
        "+\n",
        "         let user;\n",
        "+        let isNewUser = false;\n",
        "         if (authIdentity) {\n",
        "           // User already exists with this Facebook account\n",
        "           user = await storage.getUser(authIdentity.userId);\n",
        "@@ -161,14 +166,14 @@ export async function setupMultiProviderAuth(app: Express) {\n",
        "           if (email) {\n",
        "             user = await storage.getUserByEmail(email);\n",
        "           }\n",
        "-          \n",
        "+\n",
        "           if (!user) {\n",
        "             // Generate username from email or use Facebook ID as fallback\n",
        "             let username = profile.id; // fallback to Facebook ID\n",
        "             if (email && typeof email === 'string') {\n",
        "               username = email.split('@')[0].replace(/[^a-zA-Z0-9_]/g, '_');\n",
        "             }\n",
        "-            \n",
        "+\n",
        "             // Create new user\n",
        "             user = await storage.upsertUser({\n",
        "               username: username,\n",
        "@@ -178,6 +183,7 @@ export async function setupMultiProviderAuth(app: Express) {\n",
        "               lastName: lastName || undefined,\n",
        "               profileImageUrl: profileImageUrl || undefined,\n",
        "             });\n",
        "+            isNewUser = true;\n",
        "           }\n",
        " \n",
        "           // Link Facebook account to user\n",
        "@@ -208,6 +214,7 @@ export async function setupMultiProviderAuth(app: Express) {\n",
        "             firstName: user.firstName || undefined,\n",
        "             lastName: user.lastName || undefined,\n",
        "             profileImageUrl: user.profileImageUrl || undefined,\n",
        "+            isNewUser\n",
        "           };\n",
        " \n",
        "           return done(null, oauthUser);\n",
        "@@ -396,8 +403,15 @@ export async function setupMultiProviderAuth(app: Express) {\n",
        "   app.get('/api/auth/google/callback',\n",
        "     passport.authenticate('google', { failureRedirect: '/?auth=error' }),\n",
        "     (req, res) => {\n",
        "-      // Successful authentication, redirect to app\n",
        "-      res.redirect('/?auth=success');\n",
        "+      // Check if this is a new user who needs profile completion\n",
        "+      const user = req.user as OAuthUser;\n",
        "+      if (user?.isNewUser) {\n",
        "+        // New user - redirect to profile completion\n",
        "+        res.redirect(`/?auth=success&newUser=true&userId=${user.id}`);\n",
        "+      } else {\n",
        "+        // Existing user - redirect to app\n",
        "+        res.redirect('/?auth=success');\n",
        "+      }\n",
        "     }\n",
        "   );\n",
        " \n",
        "@@ -409,8 +423,15 @@ export async function setupMultiProviderAuth(app: Express) {\n",
        "   app.get('/api/auth/facebook/callback',\n",
        "     passport.authenticate('facebook', { failureRedirect: '/?auth=error' }),\n",
        "     (req, res) => {\n",
        "-      // Successful authentication, redirect to app\n",
        "-      res.redirect('/?auth=success');\n",
        "+      // Check if this is a new user who needs profile completion\n",
        "+      const user = req.user as OAuthUser;\n",
        "+      if (user?.isNewUser) {\n",
        "+        // New user - redirect to profile completion\n",
        "+        res.redirect(`/?auth=success&newUser=true&userId=${user.id}`);\n",
        "+      } else {\n",
        "+        // Existing user - redirect to app\n",
        "+        res.redirect('/?auth=success');\n",
        "+      }\n",
        "     }\n",
        "   );\n",
        " \n"
      ]
    },
    {
      "path": "server/routes.ts",
      "status": "modified",
      "additions": 59,
      "deletions": 1,
      "patch": "@@ -2722,11 +2722,69 @@ Try saying \"help me plan dinner\" in either mode to see the difference! \ud83d\ude0a`,\n   }\n }\n \n+  // STREAMING endpoint for real-time progress updates\n+  app.post(\"/api/chat/conversation/stream\", async (req, res) => {\n+    try {\n+      const { message, conversationHistory = [], mode } = req.body;\n+\n+      if (!message || typeof message !== 'string') {\n+        return res.status(400).json({ error: 'Message is required and must be a string' });\n+      }\n+\n+      const userId = (req.user as any)?.id || DEMO_USER_ID;\n+\n+      // Set up SSE headers\n+      res.setHeader('Content-Type', 'text/event-stream');\n+      res.setHeader('Cache-Control', 'no-cache');\n+      res.setHeader('Connection', 'keep-alive');\n+      res.flushHeaders();\n+\n+      const sendEvent = (event: string, data: any) => {\n+        res.write(`event: ${event}\\ndata: ${JSON.stringify(data)}\\n\\n`);\n+      };\n+\n+      try {\n+        // Send initial progress\n+        sendEvent('progress', { phase: 'starting', message: 'Analyzing your request...' });\n+\n+        if (mode === 'smart' || mode === 'quick') {\n+          const session = await storage.getActiveLifestylePlannerSession(userId);\n+          const userProfile = await storage.getUserProfile(userId);\n+\n+          // Process with streaming progress callback\n+          const langGraphResponse = await langGraphPlanningAgent.processMessage(\n+            parseInt(userId),\n+            message,\n+            userProfile,\n+            session?.conversationHistory || conversationHistory,\n+            storage,\n+            mode === 'smart' ? 'smart' : 'quick',\n+            (phase, progressMessage) => {\n+              // Stream progress to client in real-time\n+              sendEvent('progress', { phase, message: progressMessage });\n+            }\n+          );\n+\n+          sendEvent('complete', { response: langGraphResponse });\n+          res.end();\n+        } else {\n+          sendEvent('error', { message: 'Invalid mode' });\n+          res.end();\n+        }\n+      } catch (error) {\n+        sendEvent('error', { message: error instanceof Error ? error.message : 'Unknown error' });\n+        res.end();\n+      }\n+    } catch (error) {\n+      res.status(500).json({ error: 'Streaming failed' });\n+    }\n+  });\n+\n   // Real-time chat conversation endpoint with task creation\n   app.post(\"/api/chat/conversation\", async (req, res) => {\n     try {\n       const { message, conversationHistory = [], mode } = req.body;\n-      \n+\n       if (!message || typeof message !== 'string') {\n         return res.status(400).json({ error: 'Message is required and must be a string' });\n       }",
      "patch_lines": [
        "@@ -2722,11 +2722,69 @@ Try saying \"help me plan dinner\" in either mode to see the difference! \ud83d\ude0a`,\n",
        "   }\n",
        " }\n",
        " \n",
        "+  // STREAMING endpoint for real-time progress updates\n",
        "+  app.post(\"/api/chat/conversation/stream\", async (req, res) => {\n",
        "+    try {\n",
        "+      const { message, conversationHistory = [], mode } = req.body;\n",
        "+\n",
        "+      if (!message || typeof message !== 'string') {\n",
        "+        return res.status(400).json({ error: 'Message is required and must be a string' });\n",
        "+      }\n",
        "+\n",
        "+      const userId = (req.user as any)?.id || DEMO_USER_ID;\n",
        "+\n",
        "+      // Set up SSE headers\n",
        "+      res.setHeader('Content-Type', 'text/event-stream');\n",
        "+      res.setHeader('Cache-Control', 'no-cache');\n",
        "+      res.setHeader('Connection', 'keep-alive');\n",
        "+      res.flushHeaders();\n",
        "+\n",
        "+      const sendEvent = (event: string, data: any) => {\n",
        "+        res.write(`event: ${event}\\ndata: ${JSON.stringify(data)}\\n\\n`);\n",
        "+      };\n",
        "+\n",
        "+      try {\n",
        "+        // Send initial progress\n",
        "+        sendEvent('progress', { phase: 'starting', message: 'Analyzing your request...' });\n",
        "+\n",
        "+        if (mode === 'smart' || mode === 'quick') {\n",
        "+          const session = await storage.getActiveLifestylePlannerSession(userId);\n",
        "+          const userProfile = await storage.getUserProfile(userId);\n",
        "+\n",
        "+          // Process with streaming progress callback\n",
        "+          const langGraphResponse = await langGraphPlanningAgent.processMessage(\n",
        "+            parseInt(userId),\n",
        "+            message,\n",
        "+            userProfile,\n",
        "+            session?.conversationHistory || conversationHistory,\n",
        "+            storage,\n",
        "+            mode === 'smart' ? 'smart' : 'quick',\n",
        "+            (phase, progressMessage) => {\n",
        "+              // Stream progress to client in real-time\n",
        "+              sendEvent('progress', { phase, message: progressMessage });\n",
        "+            }\n",
        "+          );\n",
        "+\n",
        "+          sendEvent('complete', { response: langGraphResponse });\n",
        "+          res.end();\n",
        "+        } else {\n",
        "+          sendEvent('error', { message: 'Invalid mode' });\n",
        "+          res.end();\n",
        "+        }\n",
        "+      } catch (error) {\n",
        "+        sendEvent('error', { message: error instanceof Error ? error.message : 'Unknown error' });\n",
        "+        res.end();\n",
        "+      }\n",
        "+    } catch (error) {\n",
        "+      res.status(500).json({ error: 'Streaming failed' });\n",
        "+    }\n",
        "+  });\n",
        "+\n",
        "   // Real-time chat conversation endpoint with task creation\n",
        "   app.post(\"/api/chat/conversation\", async (req, res) => {\n",
        "     try {\n",
        "       const { message, conversationHistory = [], mode } = req.body;\n",
        "-      \n",
        "+\n",
        "       if (!message || typeof message !== 'string') {\n",
        "         return res.status(400).json({ error: 'Message is required and must be a string' });\n",
        "       }\n"
      ]
    },
    {
      "path": "server/services/langgraphPlanningAgent.ts",
      "status": "modified",
      "additions": 82,
      "deletions": 14,
      "patch": "@@ -19,6 +19,9 @@ import type { DomainConfig, Question } from './domainRegistry';\n import { domainRegistry } from './domainRegistry';\n import type { IStorage } from '../storage';\n \n+// Simple in-memory cache for enrichment data (6 hour TTL)\n+const enrichmentCache = new Map<string, { data: any; expiresAt: number }>();\n+\n /**\n  * Provider-aware function call parser\n  * Automatically detects which provider was used and calls the appropriate parser\n@@ -588,16 +591,41 @@ async function askQuestion(state: PlanningStateType): Promise<Partial<PlanningSt\n /**\n  * Node: Enrich Data\n  * Performs contextual research and planning enrichment\n+ * OPTIMIZATION: Skip for quick plans or use cached data\n  */\n async function enrichData(state: PlanningStateType): Promise<Partial<PlanningStateType>> {\n   console.log('[LANGGRAPH] Node: enrich_data');\n \n+  // OPTIMIZATION: Skip enrichment for quick plans to improve speed\n+  if (state.planMode === 'quick') {\n+    console.log('[LANGGRAPH] Skipping enrichment for quick plan mode');\n+    return {\n+      enrichedData: {\n+        contextualAdvice: 'Quick plan - using streamlined approach without detailed enrichment',\n+        domain: state.domain,\n+        timestamp: new Date().toISOString()\n+      },\n+      phase: 'synthesis'\n+    };\n+  }\n+\n   // Extract key information from slots for context-aware enrichment\n   const location = state.slots?.destination || state.slots?.location || null;\n   const dates = state.slots?.dates_duration || state.slots?.date || state.slots?.when || null;\n   const budget = state.slots?.budget || state.slots?.range || null;\n   const duration = state.slots?.duration || null;\n \n+  // OPTIMIZATION: Check cache for existing enrichment\n+  const cacheKey = `${state.domain}:${location}:${dates}:${budget}`;\n+  const cached = enrichmentCache.get(cacheKey);\n+  if (cached && cached.expiresAt > Date.now()) {\n+    console.log('[LANGGRAPH] Using cached enrichment data');\n+    return {\n+      enrichedData: cached.data,\n+      phase: 'synthesis'\n+    };\n+  }\n+\n   // Build enrichment request based on domain and extracted data\n   let enrichmentPrompt = `Based on the planning information provided, give comprehensive contextual advice including:\n \n@@ -664,12 +692,22 @@ Your advice should be:\n \n   console.log(`[LANGGRAPH] Enrichment complete (cost: $${result.usage?.totalCost.toFixed(4)})`);\n \n+  const enrichedData = {\n+    contextualAdvice: result.content,\n+    domain: state.domain,\n+    timestamp: new Date().toISOString()\n+  };\n+\n+  // OPTIMIZATION: Cache enrichment data for 6 hours\n+  const cacheKey = `${state.domain}:${location}:${dates}:${budget}`;\n+  enrichmentCache.set(cacheKey, {\n+    data: enrichedData,\n+    expiresAt: Date.now() + 6 * 60 * 60 * 1000 // 6 hours\n+  });\n+  console.log('[LANGGRAPH] Cached enrichment data');\n+\n   return {\n-    enrichedData: {\n-      contextualAdvice: result.content,\n-      domain: state.domain,\n-      timestamp: new Date().toISOString()\n-    },\n+    enrichedData,\n     phase: 'synthesis'\n   };\n }\n@@ -840,11 +878,31 @@ async function createActivity(state: PlanningStateType): Promise<Partial<Plannin\n   }\n }\n \n+/**\n+ * Node: Parallel Domain and Slot Detection\n+ * OPTIMIZATION: Run domain detection and slot extraction in parallel\n+ */\n+async function detectDomainAndSlots(state: PlanningStateType): Promise<Partial<PlanningStateType>> {\n+  console.log('[LANGGRAPH] Node: detect_domain_and_slots (parallel execution)');\n+\n+  // Run domain detection and slot extraction in parallel for speed\n+  const [domainResult, slotsResult] = await Promise.all([\n+    detectDomain(state),\n+    extractSlots(state)\n+  ]);\n+\n+  // Merge results\n+  return {\n+    ...domainResult,\n+    ...slotsResult\n+  };\n+}\n+\n /**\n  * Routing Functions\n  */\n function routeAfterDomainDetection(state: PlanningStateType): string {\n-  // Always extract slots after domain detection\n+  // Skip - now using parallel node\n   return 'extract_slots';\n }\n \n@@ -904,21 +962,19 @@ function routeAfterActivityCreation(state: PlanningStateType): string {\n function buildWorkflow() {\n   const workflow = new StateGraph(PlanningState)\n     // Add nodes\n-    .addNode('detect_domain', detectDomain)\n-    .addNode('extract_slots', extractSlots)\n+    .addNode('detect_domain_and_slots', detectDomainAndSlots)  // PARALLEL OPTIMIZATION\n     .addNode('generate_questions', generateQuestions)\n     .addNode('analyze_gaps', analyzeGaps)\n     .addNode('ask_question', askQuestion)\n     .addNode('enrich_data', enrichData)\n     .addNode('synthesize_plan', synthesizePlan)\n     .addNode('create_activity', createActivity)\n \n-    // Entry point\n-    .addEdge('__start__', 'detect_domain')\n+    // Entry point - now goes directly to parallel node\n+    .addEdge('__start__', 'detect_domain_and_slots')\n \n     // Conditional edges\n-    .addConditionalEdges('detect_domain', routeAfterDomainDetection)\n-    .addConditionalEdges('extract_slots', routeAfterSlotExtraction)\n+    .addConditionalEdges('detect_domain_and_slots', routeAfterSlotExtraction)\n     .addConditionalEdges('generate_questions', (state: PlanningStateType) => {\n       // After generating questions for the first time, show them to user (END)\n       // On subsequent turns, the questions are already generated, so we skip this node\n@@ -951,14 +1007,16 @@ export class LangGraphPlanningAgent {\n \n   /**\n    * Process a user message through the state machine\n+   * @param progressCallback - Optional callback for streaming progress updates\n    */\n   async processMessage(\n     userId: number,\n     userMessage: string,\n     userProfile: User,\n     conversationHistory: Array<{ role: string; content: string }> = [],\n     storage?: IStorage,\n-    planMode: 'quick' | 'smart' = 'quick'\n+    planMode: 'quick' | 'smart' = 'quick',\n+    progressCallback?: (phase: string, message: string) => void\n   ): Promise<{\n     message: string;\n     phase: string;\n@@ -971,6 +1029,9 @@ export class LangGraphPlanningAgent {\n     console.log(`\\n[LANGGRAPH] Processing message for user ${userId}`);\n     console.log(`[LANGGRAPH] Message: ${userMessage.substring(0, 100)}...`);\n \n+    // Emit progress if callback provided\n+    progressCallback?.('starting', 'Initializing planning workflow...');\n+\n     // Compile workflow with checkpointer\n     const app = this.workflow.compile({ checkpointer: this.checkpointer });\n \n@@ -981,21 +1042,28 @@ export class LangGraphPlanningAgent {\n       }\n     };\n \n+    progressCallback?.('domain_detection', 'Analyzing your request and extracting details...');\n+\n     const result = await app.invoke(\n       {\n         userId,\n         userMessage,\n         userProfile,\n         planMode,\n         storage,\n-        conversationHistory: [{ role: 'user', content: userMessage }]\n+        conversationHistory: conversationHistory && conversationHistory.length > 0\n+          ? conversationHistory\n+          : [{ role: 'user', content: userMessage }]\n       },\n       config\n     );\n \n     console.log(`[LANGGRAPH] Phase: ${result.phase}`);\n     console.log(`[LANGGRAPH] Progress: ${result.progress.percentage}%`);\n \n+    // Emit final progress\n+    progressCallback?.(result.phase, `Completed - ${result.progress.percentage}% done`);\n+\n     return {\n       message: result.responseMessage || \"I'm processing your request...\",\n       phase: result.phase,",
      "patch_lines": [
        "@@ -19,6 +19,9 @@ import type { DomainConfig, Question } from './domainRegistry';\n",
        " import { domainRegistry } from './domainRegistry';\n",
        " import type { IStorage } from '../storage';\n",
        " \n",
        "+// Simple in-memory cache for enrichment data (6 hour TTL)\n",
        "+const enrichmentCache = new Map<string, { data: any; expiresAt: number }>();\n",
        "+\n",
        " /**\n",
        "  * Provider-aware function call parser\n",
        "  * Automatically detects which provider was used and calls the appropriate parser\n",
        "@@ -588,16 +591,41 @@ async function askQuestion(state: PlanningStateType): Promise<Partial<PlanningSt\n",
        " /**\n",
        "  * Node: Enrich Data\n",
        "  * Performs contextual research and planning enrichment\n",
        "+ * OPTIMIZATION: Skip for quick plans or use cached data\n",
        "  */\n",
        " async function enrichData(state: PlanningStateType): Promise<Partial<PlanningStateType>> {\n",
        "   console.log('[LANGGRAPH] Node: enrich_data');\n",
        " \n",
        "+  // OPTIMIZATION: Skip enrichment for quick plans to improve speed\n",
        "+  if (state.planMode === 'quick') {\n",
        "+    console.log('[LANGGRAPH] Skipping enrichment for quick plan mode');\n",
        "+    return {\n",
        "+      enrichedData: {\n",
        "+        contextualAdvice: 'Quick plan - using streamlined approach without detailed enrichment',\n",
        "+        domain: state.domain,\n",
        "+        timestamp: new Date().toISOString()\n",
        "+      },\n",
        "+      phase: 'synthesis'\n",
        "+    };\n",
        "+  }\n",
        "+\n",
        "   // Extract key information from slots for context-aware enrichment\n",
        "   const location = state.slots?.destination || state.slots?.location || null;\n",
        "   const dates = state.slots?.dates_duration || state.slots?.date || state.slots?.when || null;\n",
        "   const budget = state.slots?.budget || state.slots?.range || null;\n",
        "   const duration = state.slots?.duration || null;\n",
        " \n",
        "+  // OPTIMIZATION: Check cache for existing enrichment\n",
        "+  const cacheKey = `${state.domain}:${location}:${dates}:${budget}`;\n",
        "+  const cached = enrichmentCache.get(cacheKey);\n",
        "+  if (cached && cached.expiresAt > Date.now()) {\n",
        "+    console.log('[LANGGRAPH] Using cached enrichment data');\n",
        "+    return {\n",
        "+      enrichedData: cached.data,\n",
        "+      phase: 'synthesis'\n",
        "+    };\n",
        "+  }\n",
        "+\n",
        "   // Build enrichment request based on domain and extracted data\n",
        "   let enrichmentPrompt = `Based on the planning information provided, give comprehensive contextual advice including:\n",
        " \n",
        "@@ -664,12 +692,22 @@ Your advice should be:\n",
        " \n",
        "   console.log(`[LANGGRAPH] Enrichment complete (cost: $${result.usage?.totalCost.toFixed(4)})`);\n",
        " \n",
        "+  const enrichedData = {\n",
        "+    contextualAdvice: result.content,\n",
        "+    domain: state.domain,\n",
        "+    timestamp: new Date().toISOString()\n",
        "+  };\n",
        "+\n",
        "+  // OPTIMIZATION: Cache enrichment data for 6 hours\n",
        "+  const cacheKey = `${state.domain}:${location}:${dates}:${budget}`;\n",
        "+  enrichmentCache.set(cacheKey, {\n",
        "+    data: enrichedData,\n",
        "+    expiresAt: Date.now() + 6 * 60 * 60 * 1000 // 6 hours\n",
        "+  });\n",
        "+  console.log('[LANGGRAPH] Cached enrichment data');\n",
        "+\n",
        "   return {\n",
        "-    enrichedData: {\n",
        "-      contextualAdvice: result.content,\n",
        "-      domain: state.domain,\n",
        "-      timestamp: new Date().toISOString()\n",
        "-    },\n",
        "+    enrichedData,\n",
        "     phase: 'synthesis'\n",
        "   };\n",
        " }\n",
        "@@ -840,11 +878,31 @@ async function createActivity(state: PlanningStateType): Promise<Partial<Plannin\n",
        "   }\n",
        " }\n",
        " \n",
        "+/**\n",
        "+ * Node: Parallel Domain and Slot Detection\n",
        "+ * OPTIMIZATION: Run domain detection and slot extraction in parallel\n",
        "+ */\n",
        "+async function detectDomainAndSlots(state: PlanningStateType): Promise<Partial<PlanningStateType>> {\n",
        "+  console.log('[LANGGRAPH] Node: detect_domain_and_slots (parallel execution)');\n",
        "+\n",
        "+  // Run domain detection and slot extraction in parallel for speed\n",
        "+  const [domainResult, slotsResult] = await Promise.all([\n",
        "+    detectDomain(state),\n",
        "+    extractSlots(state)\n",
        "+  ]);\n",
        "+\n",
        "+  // Merge results\n",
        "+  return {\n",
        "+    ...domainResult,\n",
        "+    ...slotsResult\n",
        "+  };\n",
        "+}\n",
        "+\n",
        " /**\n",
        "  * Routing Functions\n",
        "  */\n",
        " function routeAfterDomainDetection(state: PlanningStateType): string {\n",
        "-  // Always extract slots after domain detection\n",
        "+  // Skip - now using parallel node\n",
        "   return 'extract_slots';\n",
        " }\n",
        " \n",
        "@@ -904,21 +962,19 @@ function routeAfterActivityCreation(state: PlanningStateType): string {\n",
        " function buildWorkflow() {\n",
        "   const workflow = new StateGraph(PlanningState)\n",
        "     // Add nodes\n",
        "-    .addNode('detect_domain', detectDomain)\n",
        "-    .addNode('extract_slots', extractSlots)\n",
        "+    .addNode('detect_domain_and_slots', detectDomainAndSlots)  // PARALLEL OPTIMIZATION\n",
        "     .addNode('generate_questions', generateQuestions)\n",
        "     .addNode('analyze_gaps', analyzeGaps)\n",
        "     .addNode('ask_question', askQuestion)\n",
        "     .addNode('enrich_data', enrichData)\n",
        "     .addNode('synthesize_plan', synthesizePlan)\n",
        "     .addNode('create_activity', createActivity)\n",
        " \n",
        "-    // Entry point\n",
        "-    .addEdge('__start__', 'detect_domain')\n",
        "+    // Entry point - now goes directly to parallel node\n",
        "+    .addEdge('__start__', 'detect_domain_and_slots')\n",
        " \n",
        "     // Conditional edges\n",
        "-    .addConditionalEdges('detect_domain', routeAfterDomainDetection)\n",
        "-    .addConditionalEdges('extract_slots', routeAfterSlotExtraction)\n",
        "+    .addConditionalEdges('detect_domain_and_slots', routeAfterSlotExtraction)\n",
        "     .addConditionalEdges('generate_questions', (state: PlanningStateType) => {\n",
        "       // After generating questions for the first time, show them to user (END)\n",
        "       // On subsequent turns, the questions are already generated, so we skip this node\n",
        "@@ -951,14 +1007,16 @@ export class LangGraphPlanningAgent {\n",
        " \n",
        "   /**\n",
        "    * Process a user message through the state machine\n",
        "+   * @param progressCallback - Optional callback for streaming progress updates\n",
        "    */\n",
        "   async processMessage(\n",
        "     userId: number,\n",
        "     userMessage: string,\n",
        "     userProfile: User,\n",
        "     conversationHistory: Array<{ role: string; content: string }> = [],\n",
        "     storage?: IStorage,\n",
        "-    planMode: 'quick' | 'smart' = 'quick'\n",
        "+    planMode: 'quick' | 'smart' = 'quick',\n",
        "+    progressCallback?: (phase: string, message: string) => void\n",
        "   ): Promise<{\n",
        "     message: string;\n",
        "     phase: string;\n",
        "@@ -971,6 +1029,9 @@ export class LangGraphPlanningAgent {\n",
        "     console.log(`\\n[LANGGRAPH] Processing message for user ${userId}`);\n",
        "     console.log(`[LANGGRAPH] Message: ${userMessage.substring(0, 100)}...`);\n",
        " \n",
        "+    // Emit progress if callback provided\n",
        "+    progressCallback?.('starting', 'Initializing planning workflow...');\n",
        "+\n",
        "     // Compile workflow with checkpointer\n",
        "     const app = this.workflow.compile({ checkpointer: this.checkpointer });\n",
        " \n",
        "@@ -981,21 +1042,28 @@ export class LangGraphPlanningAgent {\n",
        "       }\n",
        "     };\n",
        " \n",
        "+    progressCallback?.('domain_detection', 'Analyzing your request and extracting details...');\n",
        "+\n",
        "     const result = await app.invoke(\n",
        "       {\n",
        "         userId,\n",
        "         userMessage,\n",
        "         userProfile,\n",
        "         planMode,\n",
        "         storage,\n",
        "-        conversationHistory: [{ role: 'user', content: userMessage }]\n",
        "+        conversationHistory: conversationHistory && conversationHistory.length > 0\n",
        "+          ? conversationHistory\n",
        "+          : [{ role: 'user', content: userMessage }]\n",
        "       },\n",
        "       config\n",
        "     );\n",
        " \n",
        "     console.log(`[LANGGRAPH] Phase: ${result.phase}`);\n",
        "     console.log(`[LANGGRAPH] Progress: ${result.progress.percentage}%`);\n",
        " \n",
        "+    // Emit final progress\n",
        "+    progressCallback?.(result.phase, `Completed - ${result.progress.percentage}% done`);\n",
        "+\n",
        "     return {\n",
        "       message: result.responseMessage || \"I'm processing your request...\",\n",
        "       phase: result.phase,\n"
      ]
    }
  ]
}
{
  "project": "Research Data/nlp",
  "repo": "idvorkin/nlp",
  "prior_commit": "f236b3158fdabab625e74a52b251832bdac1816f",
  "researched_commit": "ed783b2aebf9bdad2de7fedcec3a9ba9e723e7f8",
  "compare_url": "https://github.com/idvorkin/nlp/compare/f236b3158fdabab625e74a52b251832bdac1816f...ed783b2aebf9bdad2de7fedcec3a9ba9e723e7f8",
  "ahead_by": 1,
  "behind_by": 0,
  "changed_files": [
    {
      "path": "changes.py",
      "status": "modified",
      "additions": 16,
      "deletions": 2,
      "patch": "@@ -27,6 +27,16 @@\n os.environ.setdefault(\"GRPC_VERBOSITY\", \"ERROR\")\n os.environ.setdefault(\"GLOG_minloglevel\", \"2\")\n \n+# Enable gRPC fork support to prevent deadlocks when using subprocess\n+# Must be called before any gRPC usage (langchain uses gRPC internally)\n+try:\n+    import grpc.experimental\n+\n+    grpc.experimental.fork_support()\n+except (ImportError, AttributeError):\n+    # grpc module might not have fork_support in older versions\n+    pass\n+\n import asyncio\n import subprocess\n import tempfile\n@@ -405,8 +415,10 @@ def changes(\n     gist: bool = True,\n     openai: bool = False,\n     claude: bool = True,\n-    google: bool = True,\n-    llama: bool = False,\n+    google: bool = False,  # Disabled - causes resource contention with other threads\n+    llama: bool = True,\n+    kimi: bool = True,\n+    deepseek: bool = True,\n     grok4_fast: bool = True,\n     fast: bool = typer.Option(\n         False, help=\"Fast analysis using Llama and GPT-OSS models\"\n@@ -438,6 +450,8 @@ def changes(\n         claude=claude,\n         google=google,\n         llama=llama,\n+        kimi=kimi,\n+        deepseek=deepseek,\n         gpt_oss=gpt_oss,\n         grok4_fast=grok4_fast,\n     )",
      "patch_lines": [
        "@@ -27,6 +27,16 @@\n",
        " os.environ.setdefault(\"GRPC_VERBOSITY\", \"ERROR\")\n",
        " os.environ.setdefault(\"GLOG_minloglevel\", \"2\")\n",
        " \n",
        "+# Enable gRPC fork support to prevent deadlocks when using subprocess\n",
        "+# Must be called before any gRPC usage (langchain uses gRPC internally)\n",
        "+try:\n",
        "+    import grpc.experimental\n",
        "+\n",
        "+    grpc.experimental.fork_support()\n",
        "+except (ImportError, AttributeError):\n",
        "+    # grpc module might not have fork_support in older versions\n",
        "+    pass\n",
        "+\n",
        " import asyncio\n",
        " import subprocess\n",
        " import tempfile\n",
        "@@ -405,8 +415,10 @@ def changes(\n",
        "     gist: bool = True,\n",
        "     openai: bool = False,\n",
        "     claude: bool = True,\n",
        "-    google: bool = True,\n",
        "-    llama: bool = False,\n",
        "+    google: bool = False,  # Disabled - causes resource contention with other threads\n",
        "+    llama: bool = True,\n",
        "+    kimi: bool = True,\n",
        "+    deepseek: bool = True,\n",
        "     grok4_fast: bool = True,\n",
        "     fast: bool = typer.Option(\n",
        "         False, help=\"Fast analysis using Llama and GPT-OSS models\"\n",
        "@@ -438,6 +450,8 @@ def changes(\n",
        "         claude=claude,\n",
        "         google=google,\n",
        "         llama=llama,\n",
        "+        kimi=kimi,\n",
        "+        deepseek=deepseek,\n",
        "         gpt_oss=gpt_oss,\n",
        "         grok4_fast=grok4_fast,\n",
        "     )\n"
      ]
    },
    {
      "path": "docs/stuck-investigate.md",
      "status": "added",
      "additions": 300,
      "deletions": 0,
      "patch": "@@ -0,0 +1,300 @@\n+# changes.py Hang Investigation\n+\n+## Symptom\n+\n+The `changes.py` script hangs indefinitely when running with `--md-only` flag. The process becomes unresponsive and requires SIGQUIT or SIGKILL to terminate.\n+\n+**Observable behavior:**\n+\n+- Process starts normally\n+- Gets stuck after processing some files\n+- CPU usage drops to near-zero\n+- No output or progress\n+- Must be killed manually\n+\n+## Debugging Commands\n+\n+When the process hangs, use these commands to diagnose:\n+\n+```bash\n+# 1. Find the hung process\n+pgrep -f \"changes\"\n+\n+# 2. Get process details (replace PID with actual process ID)\n+/bin/ps -fp PID\n+\n+# 3. Check resource usage\n+/bin/ps -o rss,vsz,%cpu,%mem,etime -p PID\n+\n+# 4. Count threads\n+/bin/ps -M PID | wc -l\n+\n+# 5. Check open files by type\n+lsof -p PID | awk '{print $5}' | sort | uniq -c | sort -rn\n+\n+# 6. Get stack trace (macOS)\n+sample PID 1 -f /tmp/stack_trace.txt && cat /tmp/stack_trace.txt\n+\n+# 7. Alternative: Send SIGQUIT to dump Python stack (terminates process)\n+kill -QUIT PID\n+```\n+\n+**Key things to look for:**\n+\n+- **Thread count**: Should be ~3 threads. If 20+, indicates gRPC issue\n+- **Open files**: Look for excessive IPv4/unix sockets\n+- **Stack trace**: Shows what system call the main thread is stuck in\n+  - `poll` in SSL = HTTP timeout issue\n+  - `__psynch_cvwait` with gRPC = fork deadlock issue\n+  - `kevent` = waiting on async I/O\n+\n+## Root Cause Analysis\n+\n+### Stack Trace Analysis (2025-10-05)\n+\n+Crash report from PID 14340 shows a **fork deadlock** between gRPC and subprocess operations.\n+\n+**Thread 4 (The Fork Attempt):**\n+\n+```\n+fork()\n+  \u2514\u2500 _pthread_atfork_prepare_handlers\n+     \u2514\u2500 grpc_event_engine::experimental::PrepareFork()\n+        \u2514\u2500 LivingThreadCount::BlockUntilThreadCount()\n+           \u2514\u2500 WAITING FOREVER (stuck in __psynch_cvwait)\n+```\n+\n+**Thread 11 (The Deadlock):**\n+\n+```\n+grpc DNS lookup\n+  \u2514\u2500 ares_init_sysconfig_macos\n+     \u2514\u2500 dyld4::APIs::dlclose()\n+        \u2514\u2500 _os_unfair_lock_lock_slow\n+           \u2514\u2500 DEADLOCKED (stuck in __ulock_wait2)\n+```\n+\n+**The Problem:**\n+\n+1. `asyncio.create_subprocess_exec()` calls `fork()` internally\n+2. gRPC's fork preparation handler tries to wait for all threads to be in a safe state\n+3. Thread 11 is stuck in DNS initialization, holding a dyld lock\n+4. Thread 4 waits forever for Thread 11 to finish\n+5. Fork never completes \u2192 script hangs\n+\n+### Resource State at Hang\n+\n+From diagnostic commands on PID 14340:\n+\n+- **Thread count**: 20 threads spawned\n+- **gRPC threads**: Timer threads, polling threads, work-stealing thread pool\n+- **Subprocess usage**: Multiple `asyncio.create_subprocess_exec()` calls for git operations\n+\n+**Key subprocess calls in changes.py:**\n+\n+- Line 235: `is_binary_cmd` - checking if file is binary\n+- Line 268: `size_cmd` - getting file size\n+- Line 293: `which_process` - finding nbdiff command\n+- Line 310: `nbdiff_process` - diffing notebooks\n+- Line 342: `git_diff_process` - main git diff operation\n+- Line 494: Git log command\n+- Line 520: First diff for revision detection\n+- Line 544: Another git diff subprocess\n+\n+## Attempted Fixes\n+\n+### Attempt 1: Add gRPC Fork Support \u274c FAILED\n+\n+**Change:** Added `grpc.experimental.fork_support()` at script startup\n+\n+```python\n+# Enable gRPC fork support to prevent deadlocks when using subprocess\n+try:\n+    import grpc.experimental\n+    grpc.experimental.fork_support()\n+except (ImportError, AttributeError):\n+    pass\n+```\n+\n+**Location:** `/Users/idvorkin/gits/nlp/changes.py:30-37`\n+\n+**Rationale:**\n+\n+- gRPC documentation recommends this for fork-heavy applications\n+- Should configure gRPC to handle fork() calls safely\n+- Prevents blocking on thread cleanup during fork preparation\n+\n+**Result:** Still hangs - the DNS deadlock in Thread 11 occurs before fork_support can help\n+\n+### Attempt 2: Disable gRPC for Google GenAI \u23f3 TESTING\n+\n+**Change:** Force all `ChatGoogleGenerativeAI` instances to use REST transport instead of gRPC\n+\n+```python\n+model = ChatGoogleGenerativeAI(\n+    model=\"gemini-2.5-flash\",\n+    google_api_key=api_key,\n+    transport=\"rest\",  # Use REST instead of gRPC\n+)\n+```\n+\n+**Location:** `/Users/idvorkin/gits/nlp/langchain_helper.py:286-367`\n+\n+**Affected models:**\n+\n+- `gemini-2.5-pro` (line 286)\n+- `gemini-2.5-flash` (line 293)\n+- `gemini-2.5-flash` with thinking (LOW) (line 300, 318)\n+- `gemini-2.5-flash` with thinking (MEDIUM) (line 336)\n+- `gemini-2.5-flash` with thinking (HIGH) (line 354)\n+\n+**Rationale:**\n+\n+- `langchain-google-genai` supports `transport=\"rest\"` parameter\n+- REST transport avoids gRPC's threading model entirely\n+- No fork handlers, no DNS resolver threads, no dyld deadlocks\n+- Should eliminate the root cause completely\n+\n+**Result:** \u2705 FIXED gRPC deadlock! But revealed a new issue: HTTP timeout hang\n+\n+**New symptom after fix:**\n+\n+- No more gRPC threads (down from 20 threads to 3)\n+- No more DNS resolver deadlock\n+- No more dyld lock contention\n+- **BUT** now hangs in SSL socket read waiting for HTTP response\n+\n+**Stack trace after fix (PID 20142):**\n+\n+```\n+_ssl__SSLSocket_read\n+  \u2514\u2500 PySSL_select\n+     \u2514\u2500 poll (waiting indefinitely for network I/O)\n+```\n+\n+The script is now stuck waiting for an HTTP response that never arrives. This is likely:\n+\n+1. A timeout issue - no timeout set on HTTP requests\n+2. A connection that's waiting for data that will never come\n+3. An API endpoint that's hanging or rate-limiting\n+\n+### Attempt 3: Add HTTP Timeout to Google GenAI \u23f3 IN PROGRESS\n+\n+**Root cause of hang discovered:**\n+\n+The issue is **semaphore starvation**, not a simple timeout:\n+\n+```python\n+async with max_parallel:  # Semaphore acquired (line 957)\n+    result = await llm.ainvoke({})  # HTTP call holds semaphore\n+```\n+\n+**What happens:**\n+\n+1. Each LLM call acquires a semaphore slot (limit: MAX_CONCURRENT_LLM_CALLS = 100)\n+2. The HTTP request happens **while holding the semaphore**\n+3. If the HTTP call hangs indefinitely, the semaphore slot is **never released**\n+4. Eventually all 100 slots fill with hung HTTP calls\n+5. All remaining tasks wait forever for a semaphore that never frees\n+6. **Process deadlocks**\n+\n+**Fix in progress:**\n+Adding `timeout=60` to all ChatGoogleGenerativeAI instances to ensure HTTP calls fail after 60 seconds and release their semaphore slots.\n+\n+**Status:** \u2705 WORKAROUND IMPLEMENTED - Google/Gemini models disabled by default\n+\n+**Changes made:**\n+\n+1. Commented out all Google model additions in `get_models()` function (langchain_helper.py:181-198)\n+2. Changed CLI default from `google: bool = True` to `google: bool = False` (changes.py:417)\n+3. Added comment: \"Disabled - causes resource contention with other threads\"\n+4. Added kimi, deepseek, and llama to defaults for better model coverage\n+\n+**Current enabled models (defaults):**\n+\n+- \u2705 Claude (Anthropic)\n+- \u2705 Llama\n+- \u2705 Kimi\n+- \u2705 DeepSeek\n+- \u2705 Grok4 Fast\n+- \u274c Google/Gemini (disabled - can re-enable with `--google` flag if needed)\n+- \u274c OpenAI GPT (off by default)\n+\n+## Technical Details\n+\n+### gRPC Architecture Issues\n+\n+The issue stems from gRPC's complex threading model:\n+\n+1. **Timer threads** - manage timeouts and scheduled tasks\n+2. **Polling threads** - handle network I/O via completion queues\n+3. **Work-stealing thread pool** - execute callbacks and DNS lookups\n+4. **DNS resolver** - uses c-ares library with platform-specific initialization\n+\n+The macOS c-ares initialization (`ares_init_sysconfig_macos`) performs dynamic library operations that can deadlock with dyld's internal locks during fork preparation.\n+\n+### The Deadlock Chain\n+\n+```\n+Main thread                   gRPC DNS thread          Fork preparation\n+    |                              |                         |\n+    | spawn subprocess             |                         |\n+    |----------------------------->|                         |\n+    |                              | init DNS resolver       |\n+    |                              |---> dlclose()           |\n+    |                              |     [LOCKS dyld]        |\n+    | fork()                       |                         |\n+    |------------------------------|------------------------>|\n+    |                              |                         | wait for threads\n+    |                              |     [DEADLOCK]          | [BLOCKED]\n+    |     [WAITING]                |     [STUCK]             | [WAITING]\n+```\n+\n+### Why fork_support() Didn't Help\n+\n+The `grpc.experimental.fork_support()` API configures gRPC to:\n+\n+- Use pthread_atfork handlers properly\n+- Reset state in child processes\n+- Avoid some threading issues\n+\n+BUT it doesn't prevent:\n+\n+- DNS initialization deadlocks in c-ares\n+- dyld lock contention during library loading\n+- Race conditions in platform-specific code paths\n+\n+The deadlock occurs **during** DNS initialization, which is a synchronous operation in gRPC's network stack. Fork support can't interrupt or prevent this.\n+\n+## Next Steps to Try\n+\n+### Option 1: Avoid Fork Entirely\n+\n+Replace `asyncio.create_subprocess_exec()` with synchronous `subprocess.run()` or use a pre-fork subprocess pool.\n+\n+### Option 2: Defer gRPC Initialization\n+\n+Initialize langchain/gRPC clients lazily, after all subprocess operations complete.\n+\n+### Option 3: Use Process Pool\n+\n+Replace fork-based subprocess with a process pool that doesn't trigger gRPC's fork handlers.\n+\n+### Option 4: Disable DNS in gRPC\n+\n+Set environment variables to prevent gRPC from using system DNS resolver:\n+\n+```python\n+os.environ[\"GRPC_DNS_RESOLVER\"] = \"native\"\n+```\n+\n+### Option 5: Network Isolation\n+\n+Run subprocess operations before any network calls, or in separate processes entirely.\n+\n+## References\n+\n+- gRPC fork issue: https://github.com/grpc/grpc/issues/21895\n+- c-ares threading: https://c-ares.org/docs.html\n+- Python subprocess + async: https://docs.python.org/3/library/asyncio-subprocess.html\n+- macOS dyld locking: https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlopen.3.html",
      "patch_lines": [
        "@@ -0,0 +1,300 @@\n",
        "+# changes.py Hang Investigation\n",
        "+\n",
        "+## Symptom\n",
        "+\n",
        "+The `changes.py` script hangs indefinitely when running with `--md-only` flag. The process becomes unresponsive and requires SIGQUIT or SIGKILL to terminate.\n",
        "+\n",
        "+**Observable behavior:**\n",
        "+\n",
        "+- Process starts normally\n",
        "+- Gets stuck after processing some files\n",
        "+- CPU usage drops to near-zero\n",
        "+- No output or progress\n",
        "+- Must be killed manually\n",
        "+\n",
        "+## Debugging Commands\n",
        "+\n",
        "+When the process hangs, use these commands to diagnose:\n",
        "+\n",
        "+```bash\n",
        "+# 1. Find the hung process\n",
        "+pgrep -f \"changes\"\n",
        "+\n",
        "+# 2. Get process details (replace PID with actual process ID)\n",
        "+/bin/ps -fp PID\n",
        "+\n",
        "+# 3. Check resource usage\n",
        "+/bin/ps -o rss,vsz,%cpu,%mem,etime -p PID\n",
        "+\n",
        "+# 4. Count threads\n",
        "+/bin/ps -M PID | wc -l\n",
        "+\n",
        "+# 5. Check open files by type\n",
        "+lsof -p PID | awk '{print $5}' | sort | uniq -c | sort -rn\n",
        "+\n",
        "+# 6. Get stack trace (macOS)\n",
        "+sample PID 1 -f /tmp/stack_trace.txt && cat /tmp/stack_trace.txt\n",
        "+\n",
        "+# 7. Alternative: Send SIGQUIT to dump Python stack (terminates process)\n",
        "+kill -QUIT PID\n",
        "+```\n",
        "+\n",
        "+**Key things to look for:**\n",
        "+\n",
        "+- **Thread count**: Should be ~3 threads. If 20+, indicates gRPC issue\n",
        "+- **Open files**: Look for excessive IPv4/unix sockets\n",
        "+- **Stack trace**: Shows what system call the main thread is stuck in\n",
        "+  - `poll` in SSL = HTTP timeout issue\n",
        "+  - `__psynch_cvwait` with gRPC = fork deadlock issue\n",
        "+  - `kevent` = waiting on async I/O\n",
        "+\n",
        "+## Root Cause Analysis\n",
        "+\n",
        "+### Stack Trace Analysis (2025-10-05)\n",
        "+\n",
        "+Crash report from PID 14340 shows a **fork deadlock** between gRPC and subprocess operations.\n",
        "+\n",
        "+**Thread 4 (The Fork Attempt):**\n",
        "+\n",
        "+```\n",
        "+fork()\n",
        "+  \u2514\u2500 _pthread_atfork_prepare_handlers\n",
        "+     \u2514\u2500 grpc_event_engine::experimental::PrepareFork()\n",
        "+        \u2514\u2500 LivingThreadCount::BlockUntilThreadCount()\n",
        "+           \u2514\u2500 WAITING FOREVER (stuck in __psynch_cvwait)\n",
        "+```\n",
        "+\n",
        "+**Thread 11 (The Deadlock):**\n",
        "+\n",
        "+```\n",
        "+grpc DNS lookup\n",
        "+  \u2514\u2500 ares_init_sysconfig_macos\n",
        "+     \u2514\u2500 dyld4::APIs::dlclose()\n",
        "+        \u2514\u2500 _os_unfair_lock_lock_slow\n",
        "+           \u2514\u2500 DEADLOCKED (stuck in __ulock_wait2)\n",
        "+```\n",
        "+\n",
        "+**The Problem:**\n",
        "+\n",
        "+1. `asyncio.create_subprocess_exec()` calls `fork()` internally\n",
        "+2. gRPC's fork preparation handler tries to wait for all threads to be in a safe state\n",
        "+3. Thread 11 is stuck in DNS initialization, holding a dyld lock\n",
        "+4. Thread 4 waits forever for Thread 11 to finish\n",
        "+5. Fork never completes \u2192 script hangs\n",
        "+\n",
        "+### Resource State at Hang\n",
        "+\n",
        "+From diagnostic commands on PID 14340:\n",
        "+\n",
        "+- **Thread count**: 20 threads spawned\n",
        "+- **gRPC threads**: Timer threads, polling threads, work-stealing thread pool\n",
        "+- **Subprocess usage**: Multiple `asyncio.create_subprocess_exec()` calls for git operations\n",
        "+\n",
        "+**Key subprocess calls in changes.py:**\n",
        "+\n",
        "+- Line 235: `is_binary_cmd` - checking if file is binary\n",
        "+- Line 268: `size_cmd` - getting file size\n",
        "+- Line 293: `which_process` - finding nbdiff command\n",
        "+- Line 310: `nbdiff_process` - diffing notebooks\n",
        "+- Line 342: `git_diff_process` - main git diff operation\n",
        "+- Line 494: Git log command\n",
        "+- Line 520: First diff for revision detection\n",
        "+- Line 544: Another git diff subprocess\n",
        "+\n",
        "+## Attempted Fixes\n",
        "+\n",
        "+### Attempt 1: Add gRPC Fork Support \u274c FAILED\n",
        "+\n",
        "+**Change:** Added `grpc.experimental.fork_support()` at script startup\n",
        "+\n",
        "+```python\n",
        "+# Enable gRPC fork support to prevent deadlocks when using subprocess\n",
        "+try:\n",
        "+    import grpc.experimental\n",
        "+    grpc.experimental.fork_support()\n",
        "+except (ImportError, AttributeError):\n",
        "+    pass\n",
        "+```\n",
        "+\n",
        "+**Location:** `/Users/idvorkin/gits/nlp/changes.py:30-37`\n",
        "+\n",
        "+**Rationale:**\n",
        "+\n",
        "+- gRPC documentation recommends this for fork-heavy applications\n",
        "+- Should configure gRPC to handle fork() calls safely\n",
        "+- Prevents blocking on thread cleanup during fork preparation\n",
        "+\n",
        "+**Result:** Still hangs - the DNS deadlock in Thread 11 occurs before fork_support can help\n",
        "+\n",
        "+### Attempt 2: Disable gRPC for Google GenAI \u23f3 TESTING\n",
        "+\n",
        "+**Change:** Force all `ChatGoogleGenerativeAI` instances to use REST transport instead of gRPC\n",
        "+\n",
        "+```python\n",
        "+model = ChatGoogleGenerativeAI(\n",
        "+    model=\"gemini-2.5-flash\",\n",
        "+    google_api_key=api_key,\n",
        "+    transport=\"rest\",  # Use REST instead of gRPC\n",
        "+)\n",
        "+```\n",
        "+\n",
        "+**Location:** `/Users/idvorkin/gits/nlp/langchain_helper.py:286-367`\n",
        "+\n",
        "+**Affected models:**\n",
        "+\n",
        "+- `gemini-2.5-pro` (line 286)\n",
        "+- `gemini-2.5-flash` (line 293)\n",
        "+- `gemini-2.5-flash` with thinking (LOW) (line 300, 318)\n",
        "+- `gemini-2.5-flash` with thinking (MEDIUM) (line 336)\n",
        "+- `gemini-2.5-flash` with thinking (HIGH) (line 354)\n",
        "+\n",
        "+**Rationale:**\n",
        "+\n",
        "+- `langchain-google-genai` supports `transport=\"rest\"` parameter\n",
        "+- REST transport avoids gRPC's threading model entirely\n",
        "+- No fork handlers, no DNS resolver threads, no dyld deadlocks\n",
        "+- Should eliminate the root cause completely\n",
        "+\n",
        "+**Result:** \u2705 FIXED gRPC deadlock! But revealed a new issue: HTTP timeout hang\n",
        "+\n",
        "+**New symptom after fix:**\n",
        "+\n",
        "+- No more gRPC threads (down from 20 threads to 3)\n",
        "+- No more DNS resolver deadlock\n",
        "+- No more dyld lock contention\n",
        "+- **BUT** now hangs in SSL socket read waiting for HTTP response\n",
        "+\n",
        "+**Stack trace after fix (PID 20142):**\n",
        "+\n",
        "+```\n",
        "+_ssl__SSLSocket_read\n",
        "+  \u2514\u2500 PySSL_select\n",
        "+     \u2514\u2500 poll (waiting indefinitely for network I/O)\n",
        "+```\n",
        "+\n",
        "+The script is now stuck waiting for an HTTP response that never arrives. This is likely:\n",
        "+\n",
        "+1. A timeout issue - no timeout set on HTTP requests\n",
        "+2. A connection that's waiting for data that will never come\n",
        "+3. An API endpoint that's hanging or rate-limiting\n",
        "+\n",
        "+### Attempt 3: Add HTTP Timeout to Google GenAI \u23f3 IN PROGRESS\n",
        "+\n",
        "+**Root cause of hang discovered:**\n",
        "+\n",
        "+The issue is **semaphore starvation**, not a simple timeout:\n",
        "+\n",
        "+```python\n",
        "+async with max_parallel:  # Semaphore acquired (line 957)\n",
        "+    result = await llm.ainvoke({})  # HTTP call holds semaphore\n",
        "+```\n",
        "+\n",
        "+**What happens:**\n",
        "+\n",
        "+1. Each LLM call acquires a semaphore slot (limit: MAX_CONCURRENT_LLM_CALLS = 100)\n",
        "+2. The HTTP request happens **while holding the semaphore**\n",
        "+3. If the HTTP call hangs indefinitely, the semaphore slot is **never released**\n",
        "+4. Eventually all 100 slots fill with hung HTTP calls\n",
        "+5. All remaining tasks wait forever for a semaphore that never frees\n",
        "+6. **Process deadlocks**\n",
        "+\n",
        "+**Fix in progress:**\n",
        "+Adding `timeout=60` to all ChatGoogleGenerativeAI instances to ensure HTTP calls fail after 60 seconds and release their semaphore slots.\n",
        "+\n",
        "+**Status:** \u2705 WORKAROUND IMPLEMENTED - Google/Gemini models disabled by default\n",
        "+\n",
        "+**Changes made:**\n",
        "+\n",
        "+1. Commented out all Google model additions in `get_models()` function (langchain_helper.py:181-198)\n",
        "+2. Changed CLI default from `google: bool = True` to `google: bool = False` (changes.py:417)\n",
        "+3. Added comment: \"Disabled - causes resource contention with other threads\"\n",
        "+4. Added kimi, deepseek, and llama to defaults for better model coverage\n",
        "+\n",
        "+**Current enabled models (defaults):**\n",
        "+\n",
        "+- \u2705 Claude (Anthropic)\n",
        "+- \u2705 Llama\n",
        "+- \u2705 Kimi\n",
        "+- \u2705 DeepSeek\n",
        "+- \u2705 Grok4 Fast\n",
        "+- \u274c Google/Gemini (disabled - can re-enable with `--google` flag if needed)\n",
        "+- \u274c OpenAI GPT (off by default)\n",
        "+\n",
        "+## Technical Details\n",
        "+\n",
        "+### gRPC Architecture Issues\n",
        "+\n",
        "+The issue stems from gRPC's complex threading model:\n",
        "+\n",
        "+1. **Timer threads** - manage timeouts and scheduled tasks\n",
        "+2. **Polling threads** - handle network I/O via completion queues\n",
        "+3. **Work-stealing thread pool** - execute callbacks and DNS lookups\n",
        "+4. **DNS resolver** - uses c-ares library with platform-specific initialization\n",
        "+\n",
        "+The macOS c-ares initialization (`ares_init_sysconfig_macos`) performs dynamic library operations that can deadlock with dyld's internal locks during fork preparation.\n",
        "+\n",
        "+### The Deadlock Chain\n",
        "+\n",
        "+```\n",
        "+Main thread                   gRPC DNS thread          Fork preparation\n",
        "+    |                              |                         |\n",
        "+    | spawn subprocess             |                         |\n",
        "+    |----------------------------->|                         |\n",
        "+    |                              | init DNS resolver       |\n",
        "+    |                              |---> dlclose()           |\n",
        "+    |                              |     [LOCKS dyld]        |\n",
        "+    | fork()                       |                         |\n",
        "+    |------------------------------|------------------------>|\n",
        "+    |                              |                         | wait for threads\n",
        "+    |                              |     [DEADLOCK]          | [BLOCKED]\n",
        "+    |     [WAITING]                |     [STUCK]             | [WAITING]\n",
        "+```\n",
        "+\n",
        "+### Why fork_support() Didn't Help\n",
        "+\n",
        "+The `grpc.experimental.fork_support()` API configures gRPC to:\n",
        "+\n",
        "+- Use pthread_atfork handlers properly\n",
        "+- Reset state in child processes\n",
        "+- Avoid some threading issues\n",
        "+\n",
        "+BUT it doesn't prevent:\n",
        "+\n",
        "+- DNS initialization deadlocks in c-ares\n",
        "+- dyld lock contention during library loading\n",
        "+- Race conditions in platform-specific code paths\n",
        "+\n",
        "+The deadlock occurs **during** DNS initialization, which is a synchronous operation in gRPC's network stack. Fork support can't interrupt or prevent this.\n",
        "+\n",
        "+## Next Steps to Try\n",
        "+\n",
        "+### Option 1: Avoid Fork Entirely\n",
        "+\n",
        "+Replace `asyncio.create_subprocess_exec()` with synchronous `subprocess.run()` or use a pre-fork subprocess pool.\n",
        "+\n",
        "+### Option 2: Defer gRPC Initialization\n",
        "+\n",
        "+Initialize langchain/gRPC clients lazily, after all subprocess operations complete.\n",
        "+\n",
        "+### Option 3: Use Process Pool\n",
        "+\n",
        "+Replace fork-based subprocess with a process pool that doesn't trigger gRPC's fork handlers.\n",
        "+\n",
        "+### Option 4: Disable DNS in gRPC\n",
        "+\n",
        "+Set environment variables to prevent gRPC from using system DNS resolver:\n",
        "+\n",
        "+```python\n",
        "+os.environ[\"GRPC_DNS_RESOLVER\"] = \"native\"\n",
        "+```\n",
        "+\n",
        "+### Option 5: Network Isolation\n",
        "+\n",
        "+Run subprocess operations before any network calls, or in separate processes entirely.\n",
        "+\n",
        "+## References\n",
        "+\n",
        "+- gRPC fork issue: https://github.com/grpc/grpc/issues/21895\n",
        "+- c-ares threading: https://c-ares.org/docs.html\n",
        "+- Python subprocess + async: https://docs.python.org/3/library/asyncio-subprocess.html\n",
        "+- macOS dyld locking: https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlopen.3.html\n"
      ]
    }
  ]
}